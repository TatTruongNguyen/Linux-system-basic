# Linux-system-basic

Linux System Basic
# Mục lục
## 1. Getting Started 
   - History
   - Choosing a Linux Distribution
   - Debian
   - Red Hat Enterprise Linux
   - Ubuntu
   - Fedora
   - Linux Mint
   - Gentoo
   - Arch Linux
   - openSUSE

## 1. Getting Started
 - History
    - Năm 1969, Ken Thompson và Dennis Ritchie của phòng thí nghiệm Bell phát triển hệ điều hành Unix. Sau đó được viết lại bằng C, và cuối cùng trở thành một hệ điều hành được sử dụng rộng rãi.
    - Khoảng 1 thập kỷ sau, Richard Stallman bắt đầu làm việc với dự án GNU, hạt nhân GNU được gọi là Hurd.
    - Kernel là phần quan trọng nhất trong hệ điều hành. Nó cho phép phần cứng giao tiếp với phần mềm. Hạt nhân kiểm soát mọi thứ xảy ra trên hệ thống.
    - Năm 1991, Linus Torvalds phát triển ra thứ mà sau này được biết đến là nhân Linux. 
 
 - Choosing a Linux Distribution
   -  Hệ thống Linux được chia làm ba phần chính:
     - Phần cứng - Bao gồm tất cả phần cứng mà hệ thống chạy trên đó
     - Kernel Linux - Là cốt lõi của hệ điều hành. Nó quản lý phần cứng và cho biết cách tương tác với hệ thống
     - Không gian người dùng - Nơi những người dùng sẽ tương tác với hệ thống một cách trực tiếp
   - Có nhiều tuỳ chọn về các bản phân phối Linux cho người dùng lựa chọn.
 
 - Debian   
   - Là hệ điều hành bao gồm hoàn toàn phần mềm mã nguồn mở và miễn phí, được biết đến rộng rãi và được phát triển trong hơn 20 năm. Có thể sử dụng 3 nhánh: Ổn định, Kiểm tra và Không ổn định. 
   - Quản lý gói, sử dụng các công cụ quản lý gói Debian. Mỗi bản phân phối sẽ được cài đặt và quản lý các gói khác nhau và chúng sử dụng các công cụ quản lý gói khác nhau.
   - Khả năng cấu hình, tuy có thể không nhận được các bản cập nhật mới nhất nhưng sẽ cực kì ổn định.
   - Sử dụng, là một hệ điều hành tổng thể tuyệt vời cho mọi nền tảng.
   
 - Red Hat Enterprise Linux
   - Tổng quan, thường được gọi tắt là RHEL được phát triển bởi Red Hat. Có các quy tắc nghiêm ngặt để hạn chế việc phân phối lại miễn phí mặc dù vẫn cung cấp mã nguồn miễn phí.
   - Quản lý gói, RHEL sử dụng trình quản lý gói khác với Debian, RHEL sử dụng trình quản lý gói RPM.
   - Khả năng cấu hình, Hệ điều hành dựa trên RHEL khác một chút so với hệ điều hành dựa trên Debian, đáng chú ý nhất là trong quản lý gói.
   - Công dụng, Chủ yếu sẽ được sử dụng trong doanh nghiệp, nếu cần một hệ điều hành máy chủ vững chắc thì đây sẽ là một sự lựa chọn tốt.
 
 - Ubuntu
   - Tổng quan, là bản phân phối Linux phổ biến nhất cho máy cá nhân, cũng phát hành Unity cho trình quản lý môi trường máy tính.
   - Quản lý gói, là hệ điều hành dựa trên Debian được phát triển bởi Canonical. Vì vậy nó sử dụng một hệ thống quản lý Debian cốt lõi.
   - Khả năng cấu hình, là sự lựa chọn tuyết vời cho người mới làm quen với Linux. Mang lại khả năng sử dụng dễ dàng và trải nghiệm tuyệt vời.
   - Sử dụng tuyệt vời cho mọi nền tảng.
 - Fedora
   - Được Red Hat hỗ trợ, mang tính cộng đồng bao gồm phần mềm nguồn mở và miễn phí. Fedora như một hệ điều hành RHEL ngược dòng vì là phân nhánh của RHEL.
   - Quản lý gói, sử dụng trình quản lý gói Red Hat.
   - Khả năng cấu hình, nếu như người dùng muốn sử dụng hệ điều hành dựa trên Red Hat thì đây sẽ là phiên bản thân thiện với người dùng.
   - Sử dụng, là hệ điều hành tốt nếu người dùng muốn có hệ điều hành dựa trên Red Hat.
 - Linux Mint
   - Linux Mint dựa trên Ubuntu, sử dụng kho phần mềm của Ubuntu, sẽ là bản phân phối nhẹ hơn Ubuntu.
   - Sử dụng trình quản lý gói Debian.
   - Giao diện người dùng tuyệt vời, tốt cho người mới bắt đầu và ít phức tạp hơn Ubuntu.
   - Sử dụng tốt cho máy tính PC và laptop.
 - Gentoo
   - Mang lại sự linh hoạt, được tạo ra cho những người dùng cao cấp.
   - Sử dụng trình quản lý gói của riêng mình, Portage. Việc quản lý gói Portage rất dễ bảo trì, linh hoạt, đóng vai trò quan trọng trong toàn bộ hệ điều hành.
   - Muốn đi theo con đường khó khăn hơn khi mới bắt đầu Linux thì nên chọn Gentoo.
   - Sử dụgn tuyệt vời cho PC và laptop.
 - Arch Linux
   - Là bản phân phối nhẹ và linh hoạt được thúc đẩy 100% từ cộng đồng. Arch sử dụng mô hình phát hành luân phiên như Debian.
   - Sử dụng trình quản lý gói của riêng mình, Pacman, để cài đăt, cập nhật và quản lý các gói.
   - Là một sự lựa chọn tốt nếu muốn có một hệ điều hành nhẹ và muốn hiểu về Linux.
 - openSUSE
   - Được tạo ra bởi dự án openSUSE. Là bản phân phố Linux lâu đời thứ hau vẫn đang chạy và chia sẻ hệ thống cơ sở.
   - Sử dụng trình quản lý gói RPM.
   - Là lựa chọn tuyệt vời cho người mới dùng Linux. Cung cấp một trình cài đặt, ứng dụng quản trị đồ hoạ dễ sử dụng và một hệ thống cơ sở hàng ngày dễ sửa chữa. Bao gồm mọi thứ để tận hưởng Internet không lo virus hay các phần mềm gián điệp.
   - openSUSE Leap hoàn toàn có khả năng được sử dụng trên PC và laptop.

## 2. Command Line
 - The Shell
   - Là chương trình lấy các lệnh từ bàn phím và gửi tới hệ điều hành để thực hiện. Các bản phân phối sẽ mặc định là **bash shell** .
   - Sẽ tuân theo định dạng sau:
   ```
   username@hostname:current_directory
   pete@icebox:/home/pete $  
   ```
   $ ở cuối lời nhắc, các shell khác nhau sẽ có các lời nhắc khác nhau, như ví dụ trên thì $ dành cho người dùng bình thường sử dùng Bash.
   - Lệnh **echo** , lệnh **echo** chỉ in các đối số văn bản ra màn hình
   ```
   $ echo Hello World
   ```
 
 - pwd (Print Working Directory)
   - Mọi thứ trong Linux đều là một tệp, mọi tệp đều được tổ chức trong một cây thư mục phân cấp. Thư mục đầu tiên trong hệ thống tập tin được đặt tên phù hợp là thư mục gốc. Thư mục gốc có nhiều thư mục và tệp có thể lưu trữ nhiều thư mục và tệp hơn. Và đây là ví dụ về cây thư mục:
    ```
    / 
      | - bin
 
      | | - tập tin1
 
      | | - file2
 
      | - vv
 
      | | - tập tin3
 
      | `- thư mục1
 
      | | - tập tin4
 
      | `- file5
 
      | - home
 
      | - var 
     ``` 
    - Vị trí của các tệp và thư mục này được gọi là đường dẫn. Nếu có một thư mục tên là home với một thư mục bên trong có tên là abc thì đường dẫn đó sẽ là /home/abc.
    - Nếu muốn biết mình đang ở đâu hãy gõ theo lệnh sau:
      ```
      $ pwd
      ```
 - cd (Change Directory)
   - Có 2 cách để chỉ định một đường dẫn, với các đường dẫn tuyệt đối và đường dẫn tương đối
     - Đường dẫn tuyệt đối: Là đường dẫn từ thư mục gốc. Thư mục gốc thường được hiển thị dưới dạng dấu gạch chéo. Mỗi khi đường dẫn bắt đầu bằng / thì sẽ là đang bắt đầu từ thư mục gốc. Ví dụ: / home / truong / Desktop.
     - Đường dẫn tương đối: Là đường dẫn từ nơi hiện tại ở trong hệ thống tệp. 
   - Ví dụ
     ```
     $ cd / home / truong / Hình ảnh
     ```
   - Hiện tại đã thay đổi vị trí thư mục thành / home / truong / Hình ảnh. Ví dụ như đã có một thư mục bên trong tên là abc thì có thể điều hướng bằng lệnh
     ```
     $ cd abc
     ```
   - Có một số phím tắt để giúp điều hướng nhanh hơn
     - . (Thư mục hiện tại): Là thư mục hiện đang ở.
     - .. (Thư mục mẹ): Đưa tới thư mục phía trên của hiện tại.
     - ~ (Thư mục chính): Mặc định là thư mục chính.
     - - (Thư mục trước): Đưa tới thư mục trước đó vừa ở.
     ```
     $ cd.
     $ cd ..
     $ cd ~
     $ cd -
     ```
 
 - ls (List Directories)
   - Là lệnh liệt kê nội dung thư mục 
     ```
     $ ls
     $ ls / home / pete
     ```
   - Để liệt kê các tệp ẩn sử dụng lệnh
     ```
     $ ls -a
     ```
   - Liệt kê các tệp ở định dạng dài, hiển thị thông tin chi tiết
     ```
     $ ls -l
     ```
   - Liệt kê đầy đủ 
     ```
     $ ls -la
     ```
 
 - touch
   - Cho phép tạo các tệp trống mới
     ```
     $ touch mysuperduperfile
     ```
   - Ngoài ra cũng có thể được sử dụng để thay đổi dấu thời gian trên các tệp và thư mục. Thực hiện ls -l trên một tệp và ghi lại dấu thời gian, sau đó sử dụng touch trên tệp đó sẽ cập nhật dấu thời gian.
 - file
   - Hiển thị mô tả về nội dung của tệp sử dụng lệnh
     ```
     $ file banana.jpg
     ```
 
 - cat
   - Cho phép người dùng tạo một hoặc nhiều file, xem nội dung file
     ```
     $ cat dogfile birdfile
     ```
 
 - less
   - Cho phép điều hướng thông qua các nội dung tập tin và tìm kiếm các chuỗi.
     ```
     $ less / home / pete / Documents / text1
     ```
   - Lệnh điều hướng
     - q : Thoát
     - Điều hướng bằng các phím mũi tên
     - g : chuyển đến đầu tệp văn bản
     - G : chuyển đến cuối tệp văn bản
     - / search : tìm kiếm văn bản cụ thể bên trong tài liệu, luôn có / trước các từ muốn tìm kiếm
     - h : gọi trợ giúp
 
 - history
   - Thực hiện lệnh để xem lại lệnh đã dùng trước đó
     ```
     $ history
     ```
   - Dọn dẹp màn hình 
     ```
     $ clear
     ```
 
 - cp (Copy)
   - Sao chép tệp mycoolfile vào cooldocs
     ```
     $ cp mycoolfile / home / pete / Documents / cooldocs
     ```
   - Sử dụng các kí tự giúp công việc linh hoạt hơn
     - * : dùng để đại diện cho tất cả các kí tự đơn hoặc bất kỳ chuỗi nào.
     - ? : được sử dụng để đại diện cho một ký tự.
     - [] : được sử dụng để đại diện cho bất kỳ kí tự nào trong dấu ngoặc.
       ```
       $ cp * .jpg / home / pete / Pictures
       ```
   - Sử dụng -r để sao chép các tệp và thư mục trong một thư mục
     ```
     $ cp -r Pumpkin / / home / pete / Documents
     ```
   - Sử dụng -i để nhắc người dùng trước khi ghi đè tệp
     ```
     $ cp -i mycoolfile / home / pete / Pictures
     ```
 
 - mv (Move)
   - Sử dụng để di chuyển các tệp và cũng có thể đổi tên chúng
   - Đổi tên tệp ``` $ mv oldfile newfile ```
   - Di chuyển tệp đến thư mục khác ``` $ mv file2 / home / pete / Documents ```
   - Di chuyển nhiều tệp ``` $ mv file_1 file_2 / somedirectory ```
   - Đổi tên các thư mục ``` $ mv directory1 directory2 ```
   - Sử dụng -i để nhắc trước khi ghi đè ``` mv -i directory1 directory2 ```
   - Nếu muốn ghi đè tệp trước đó, có thể tạo bản sao lưu của tệp đó và nó sẽ chỉ đổi tên phiên bản cũ bằng dấu ~ ``` $ mv -b directory1 directory2 ```
 
 - mkdir (Make Directory)
   - Lệnh tạo thư mục, có thể tạo nhiều thư mục cùng lúc ``` $ mkdir books paintings ```
   - Dùng -p để có thể tạo thư mục con ``` $ mkdir -p books / hemmingway / favorites ```
 
 - rm (Remove)
   - Sử dụng đẻ xoá tệp và thư mục ``` $ rm file1 ```
   - Xoá nhiều tệp sử dụng -f ``` $ rm -f file1 ```
   - Thêm -i để tạo nhắc nhở có muốn xoá hay không ``` $ rm -i file ```
   - Thêm -r để có thể xoá tất cả các tệp và bất kỳ thư mục con nào mà nó có thể có ``` $ rm -r directory ```
   - Xoá thư mục ``` $ rmdir directory ```
 
 - find
   - Tìm kiếm các tệp trên hệ thống ``` $ find / home -name puppies.jpg ```
   - Sẽ phải chỉ định thư mục sẽ tìm kiếm 
   - Chỉ định loại tệp đang tìm ``` $ find / home -type d -name MyFolder ```
   
 - help
   - Lệnh chạy trợ giúp
   - Cung cấp mô tả và tuỳ chọn có thể sử dụng khi chạy echo ```  $ help echo ```
   - Đối với các chương trình thực thi khác, quy ước phải có một tuỳ chọn --help ``` $ echo --help ```
   
 - man
   - Xem hướng dẫn sử dụng của ls bằng lệnh ``` $ man ls ```    
   
 - whatis
   - Là lệnh cung cấp mô tả ngắn gọn về chương trình dòng lệnh 
   - Mô tả về chương trình dòng lệnh cat ```  $ whatis cat ```
 
 - alias
   - Tạo bí danh cho 1 lệnh, chỉ cần chỉ định tên bí danh và đặt nó thành lệnh
   - ví dụ thay vì gõ ls-la thì ta gõ foobar nó sẽ thực thi lệnh ``` $ alias foobar = 'ls -la' ```
   - Nếu muốn nó tồn tại sau khi khởi động lại ``` ~ / .bashrc ```
   - Xoá bí danh ``` unalias foobar ```
   
 - exit 
   - Thoát ta sẽ nhập lệnh ``` $ exit ```
   - Lệnh đăng xuất ``` $ logout ```  

## 3. Text-Fu
 - stdout (Standard Out)
   - Chuyển hướng nối đầu ra vào một tệp như ví dụ ``` $ echo Hello World > peanuts.txt ``` file text peanuts.txt sẽ có nội dung Hello World.
   - Ở đây, > là toán tử chuyển hướng cho phép thay đổi đầu ra tiêu chuẩn. Thay vì đưa ra màn hình thì khi sử dụng > nó sẽ đưa đầu ra vào tệp.
   - Nếu không muốn ghi đè thì ta sẽ sử dụng toán tử >> thay vì >.
   
 - stdin (Standard In)
   - Tương tự stdout thì stdin sẽ dùng toán tử < để chuyển hướng.
   - Ví dụ ``` $ cat < peanuts.txt > banana.txt ``` ở đây peanuts.txt được chuyển hướng thành stdin. Và đầu ra bên trong tệp peanuts.txt sẽ được chuyển hướng tới file mới là banana.txt.
   
 - stderr (Standard Error)
   - Ví dụ liệt kê nội dung của thư mục không tồn tại và chuyển hướng kết quả đầu ra tới tệp peanuts.txt ``` $ ls /fake/directory > peanuts.txt ``` và kết quả hiển thị như sau ``` ls: cannot access /fake/directory: No such file or directory ```
   - Lí do lỗi vậy là đã gặp lỗi tiêu chuẩn, vậy nên sẽ cần chuyển hướng đầu ra theo một cách khác.
   - Cần sử dụng bộ mô tả tệp, bộ mô tả tệp là một số không âm được sử dụng để truy cập tệp hoặc luồng. Bộ mô tả tệ cho stdin, stdout, stderr lần lượt là 0,1,2.
   - Để chuyển hướng ta sẽ sử dụng như sau: ``` $ ls /fake/directory 2> peanuts.txt ``` , Sẽ chỉ nhìn thấy các thông báo stderr trong peanuts.txt.
   - Để xem cả nội stderr và stout trong peanuts.txt sẽ thực hiện ``` $ ls /fake/directory > peanuts.txt 2>&1 ```. Thao tác này sẽ gửi kết quả của ls/fake/ đến peanuts.txt sau đó chuyển hướng stderr đến stdout qua 2>&1.
   - Chuyển hướng stdout và stderr đến một tệp ``` $ ls /fake/directory &> peanuts.txt ```
   - Loại bỏ các tin thông báp stderr thì sẽ cần chuyển hướng đầu ra đếp tệp đặc biệt ``` $ ls / fake / directory 2> / dev / null ```
   
 - pipe and tee
   - Hiển thị danh sách dài các mục ``` $ ls -la /etc ```
   - Hiển thị các mục như danh sách sẽ ngắn gọn hơn ``` $ ls -la /etc | less ```
   - Toán tử pipe biểu thị bằng | , cho phép lấy đoạn mã của một lệnh và chuyển đoạn lệnh đó sang một quá trình khác.
   - Muốn viết đàu ra của lệnh vào 2 luồng khác nhau, thực hiện lệnh tee ``` $ ls | tee peanuts.txt ``` Kết quả đàu ra của ls trên màn hình và nếu mở tệp sẽ thấy thông tin tương tự trên màn hình.
   
 - env (Environment)
   - ``` $ echo $HOME ``` sẽ thấy đường dẫn đến thư mục của mình.
   - ``` $ echo $ USER ``` sẽ thấy tên người dùng.
   - ``` $ env ``` xuất ra các thông tin về các biến môi trường mà đã được cài đặt. Các biến này chứa thông tin mà shell và các quy trình có thể sử dụng, ví dụ:
     ```
     PATH = / usr / local / sbin: / usr / local / bin: / usr / sbin: / bin
     PWD = / home / user
     USER = pete
     ```
   - Biến PATH có thể truy cập bằng cách $ ở trước tên biến 
     ```
     $ echo $ PATH
     / usr / local / sbin: / usr / local / bin: / usr / sbin: / bin
     ```
   - Trả về một danh sách các đường dẫn được phân tách bằng dấu : mà hệ thống sẽ tìm kiếm khi nó chạy một lệnh.
   
 - cut
   - ``` $ echo 'The quick brown; fox jumps over the lazy  dog' > sample.txt ```, thêm tab vào giữa lazy và dog
   - Trích xuất các văn bản từ một tệp ta sử dụng lệnh cut
   - Trích xuất nội dung theo danh sách các ký tự ``` $ cut -c 5 sample.txt ``` , xuất ra ký tự thứ 5 trong mỗi dòng của tệp.
   - ``` $ cut -f 2 sample.txt ``` , -f cắt văn bản dựa trên các trường. Đầu ra sẽ là dog vì được phân tách các trường bởi tab.
   - ``` $ cut -f 1 -d ";" sample.txt ``` Thay đổi dấu phân tách tab thành dấu ";" do đó kết quả là the quick brown do cắt trường đầu tiên.
 
 - paste
   - Tương tự như cat, nó sẽ kết hợp các dòng với nhau trong tệp
     ```
     sample2.txt
     The
     quick
     brown
     fox
     ```
   - Kết hợp các dòng trên thành một dòng ``` $ paste -s sample2.txt ```
   - Dấu phân tách mặc định để dán là Tab, thay đổi dấu phân tách cho dễ đọc bằng -d ``` $ paste -d '' -s sample2.txt ``` , kết quả sẽ là mọi thứ nằm trên một dòng và được phân tách bằng dấu cách.
   
 - head 
   - Hiển thị 10 dòng đầu tiên trong tệp thay vì tất cả ``` $ head /var/log/syslog ```
   - Có thể sửa đổi số dòng bằng bất kì điều gì mong muốn, ví dụ sửa muốn xem 15 dòng đầu tiên ``` $ head -n 15 / var / log / syslog ``` , -n là viết tắt của số dòng.
   
 - tail
   - Tương tự head thì tail sẽ cho phép xem 10 dòng cuối cùng của tệp theo mặc định ``` $ tail / var / log / syslog ```
   - Có thể thay đổi số dòng muốn xem ``` $ tail -n 10 / var / log / syslog ```
   - Sử dụng -f để theo dõi tệp khi nó phát triển. Cung cấp và xem nhữn gì xảy ra ``` $ tail -f / var / log / syslog ```
   
 - expand and unexpand
   - Về mặc định sẽ luôn là Tab được sử dụng nhưng nếu muốn thay Tab thành dấu cách ta sử dụng lệnh expand ``` $ expand sample.txt ``` , sẽ in đầu ra với mỗi tab được chuyển đổi thành khoảng trống để lưu đầu ra trong 1 tệp ta sẽ sử dụng chuyển hướng đầu ra ``` $ expand sample.txt> result.txt ```
   - Để chuyển đổi ngược lại từ dấu cách thành tab ta thực hiện lệnh unexpand ``` unexpand -a result.txt ```
   
 - join and split
   - Cho phép kết nối nhiều tệp với nhau bằng một trường chung
     ```
     file1.txt
     1 John
     2 Jane
     3 Mary

     file2.txt
     1 Doe
     2 Doe
     3 Sue

     $ join file1.txt file2.txt
     1 John Doe
     2 Jane Doe
     3 Mary Sue
     ```
   - Để kết nối khi không giống nhau ta sẽ sử dụng
     ```
     $ join -1 2 -2 1 file1.txt file2.txt
     1 John Doe
     2 Jane Doe
     3 Mary Sue
     ```
   - Sử dụng lệnh tách để chia 1 tệp thành các tệp khác nhau ``` $ split somefile ```
   
 - sort
   - $ sort file1.txt : sắp xếp theo chữ cái đầu dòng
   - $ sort -r file1.txt : sắp xếp ngược lại
   - $ sort -n file1.txt : sắp xếp theo giá trị số
   
 - tr (Translate)
   - Cho phép dịch một bộ ký tự thành bộ ký tự khác, ví dụ dịch từ ký tự thường sang ký tự in hoa ``` $ tr az AZ ```
 
 - uniq (Unique)
   - Lệnh để phân tích cú pháp văn bản
   - Ví dụ têp có nhiều bản sao sẽ dùng lệnh uniq để xoá bản sao ``` $ uniq reading.txt ```
   - Tính xem số lần xuất hiện ``` $ uniq -c reading.txt ```
   - Lấy các giá trị duy nhất ``` $ uniq -u reading.txt ```
   - Lấy các giá trị trùng lặp ``` $ uniq -d reading.txt ```  
   - uniq không phát hiện các dòng trùng trừ khi chúng ở gần nhau, do đó để khắc phục ta sẽ sử dụng sort kết hợp với uniq ``` $ sort reading.txt | uniq ```
   
 - wc and nl 
   - wc sẽ hiển thị tổng số từ trong một tệp ``` $ wc /etc/passwd ``` , hiển thị số dòng, số từ và số byte tương ứng.
   - Sử dụng -l, -w, -c để xem số lượng của mỗi trường nhất định.
   - Có thể sử dụng nl để kiểm tra số dòng trên tệp ``` $ nl file1.txt ```
   
 - grep
   - Cho phép bạn tìm kiếm các tệp cho các ký tự phù hợp với một mẫu nhất định ``` $ grep fox sample.txt ``` tìn fox trong sample.txt
   - Phân biệt các mẫu chữ hoa chữ thường với -i ``` $ grep -i somepattern somefile ```
   - Kết hợp với các lệnh khác bằng | ``` $ env | grep -i User ```
   - ``` $ ls / somedir | grep '.txt $' ``` Trả về các tệp kết thúc bằng .txt xong somedir.  
 
## 4. Advanced Text-Fu
 - regrex (Regular Expressions)
   - Biểu thức chính quy sử dụng ký tự 
     ```
     sally sells seashells 
     by the seashore
     ```
   - Bắt đầu bằng ^ ``` ^by ``` kết quả sẽ khớp là by the seashore.
   - Kết thúc bằng $ ``` seashore$ ``` kết quả sẽ khớp là by the seashore.
   - So khớp với bất kì ký tự đơn nào với . ``` b. ``` sẽ phù hợp với by.
   - Có ký hiệu [] ``` d [iou] g ``` sẽ khớp với dig, dog, dug.
   - Có ^ trước ký tự trong [] là tất cả những gì ngoài dấu ngoặc.
   - Ngoài ra dấu [] cũng giúp tăng phạm vi số lượng ký tự muốn sử dụng ``` d [a-c] g ```
   - Dấu ngoặc phân biệt chữ hoa và chữ thường.
   
 - Text Editors
   - Vim và emacs là những trình soạn thảo văn bản phổ biến được cài đặt mặc định trên hầu hết các bản phân phối Linux và cả 2 đều có ưu và nhược điểm riêng.
   - Chúng là mã hoá, xử lý tài liệu văn bản và về cơ bản là tất cả trong một trình soạn thảo.
   
 - Vim (Vi Improved)
   - Là viết tắt của phiên bản cải tiến của lệnh soạn thảo văn bản vi.
   - Siêu nhẹ, việc mở và chỉnh sủa tệp bằng vim nhanh chóng và dễ dàng, gần như luôn có sẵn.
   - Để kích hoạt chỉ cần gõ ``` vim ```
   
 - Vim Search Patterns
   - Khi cần tìm kiếm chỉ cần nhập / sau đó nhập kết quả tìm kiếm khi đang ở trong vim. Sau khi enter có thể ấn n để tiến và N để lùi 
   - Có thể dùng ? để tìm kiếm ngược so với /
   
 - Vim Navigation
   - Để điều hướng trong vim ta sử dụng các phím sau:
     ```
     h hoặc mũi tên trái để di chuyển sang trái
     k hoặc mũi tên lên để di chuyển lên dòng trên
     j hoặc mũi tên xuống để di chuyển xuống dòng dưới
     l hoặc mũi tên phải để di chuyển sang phải
     ```
 - Vim Appending Text
   - Khi đang ở chế độ lệnh sẽ không thể nhập được, để có thể nhập thì trước tiên ta sẽ cần vào chế độ chèn
   - Gõ i : chèn văn bản trước con trỏ
   - Gõ O : chèn văn bản trên dòng trước
   - Gõ o : chèn văn bản vào dòng tiếp theo
   - Gõ a : nối văn bản sau con trỏ
   - Gõ A : nối văn bản vào cuối dòng
   - Để thoát khoải chế độ chèn và quay lại chế độ lệnh, sử dụng phím Esc
   
 - Vim Editing
   - Để có thể chỉnh sửa trong vim ta sẽ có những phím sau đây
   - x : dùng để cắt văn bản đã chọn hay cũng được sử dụng để xóa các ký tự
   - dd : dùng để xóa dòng hiện tại
   - y : kéo hoặc sao chép bất cứ thứ gì được chọn
   - yy : kéo hoặc sao chép dòng hiện tại
   - p : dán văn bản đã sao chép trước con trỏ
   
 - Vim Saving and Exiting
   - Để có thể lưu và thoát khỏi vim ta sẽ thực hiện như sau
   - :w : dùng để ghi hoặc lưu tệp
   - :q : dùng để thoát khỏi vim
   - :wq : viết sau đó thoát khỏi vim
   - :q! : thoát khỏi vim mà không lưu tệp
   - ZZ : tương đương với :wq, nhưng nhanh hơn
   - u : hoàn tác hành động cuối cùng của bạn
   - Ctrl + r : thực hiện lại hành động cuối cùng
   
 - Emacs
   - Dành cho những người dùng muốn có trình soạn thảo văn bản cực kỳ mạnh mẽ, có thể thực hiện tất cả việc chỉnh sửa mã, thao tác tệp...
   - Để bắt đầu chỉ cần gõ ``` emacs ```
   - Bộ đệm trong emacs là nơi chứa văn bản. Vì vậy, nếu mở một tệp, bộ đệm sẽ được sử dụng để lưu trữ nội dung của tệp đó. Có thể mở nhiều bộ đệm cùng lúc và có thể dễ dàng chuyển đổi giữa các bộ đệm.
   
 - Emacs Manipulate Files
   - Để lưu tệp
     - C-x C-s : Lưu tệp
     - C-x C-w : Lưu tệp dưới dạng
     - C-x s : Lưu tất cả
   - Mở tệp
     - C-x C-f         
 
 - Emacs Buffer Navigation
   - Để di chuyển xung quanh bộ đẹp, ta sử dụng các lệnh sau
   - Chuyển đổi bộ đệm
     - C-x b : chuyển đổi bộ đệm
     - C-x right arrow : di chuyển sang phải bộ đệm
     - C-x left arrow : di chuyển sang trái bộ đệm
   - Đóng bộ đệm
     - C-x k
   - Tách bộ đệm hiện tại
     - C-x 2 
   - Đặt một bộ đệm duy nhất làm màn hình hiện tại           
     - C-x 1
 
 - Emacs Editing
   - Điều hướng văn bản
     ```
     C-up arrow : di chuyển lên một đoạn
     C-down arrow: di chuyển xuống một đoạn
     C-left arrow: di chuyển một từ sang trái
     C-right arrow: di chuyển một từ sang phải
     M-> : di chuyển đến cuối vùng đệm
     ```
   - Cắt và dán
     - Trước tiên cần phải chọn văn bản, di chuyển con trỏ đến nơi muốn cắt hoặc dán sau đó nhấn ``` C-space key ```
     - Sau đó có thể cắt và dán bằng cách C-w : cắt, C-y : dán.
 
 - Emacs Exiting and Help
   - Để đóng Emacs ``` C-x C-c ```
   - Cần trợ giúp ``` C-h C-h : help menu ```
   - Hoàn tác ``` C-x u ```
 
## 5. User Management 
 - Users and Groups
   - Trong bất kỳ hệ điều hành truyền thống nào, đều có người dùng và nhóm. Chúng chỉ tồn tại cho quyền truy cập và quyền.
   - Mỗi người dùng có thư mục chính của riêng họ, nơi các tệp người dùng cụ thể của họ được lưu trữ, thư mục này thường nằm trong / home / username, nhưng có thể khác nhau trong các bản phân phối khác nhau.
   - Hệ thống sử dụng mã người dùng (UID) để quản lý người dùng, tên người dùng là cách thân thiện để liên kết người dùng với nhận dạng, nhưng hệ thống xác định người dùng bằng UID của họ. Hệ thống cũng sử dụng nhóm để quản lý quyền, nhóm chỉ là tập hợp người dùng có quyền do nhóm đó thiết lập, họ được hệ thống xác định bằng ID nhóm (GID) của họ.
   - Trong Linux, bạn sẽ có người dùng ngoài những người bình thường sử dụng hệ thống. Đôi khi những người dùng này là daemon hệ thống liên tục chạy các quy trình để giữ cho hệ thống hoạt động. Một trong những người dùng quan trọng nhất là root hoặc superuser, root là người dùng mạnh nhất trên hệ thống, root có thể truy cập bất kỳ tệp nào và bắt đầu và kết thúc bất kỳ quá trình nào.
   - Để có thể chạy với quyền root sử dụng lệnh ``` sudo ```
   
 - root
  - Có thể chạy các lệnh với tư cách là superuser bằng lệnh ``` su ```. Lệnh này sẽ "thay thế người dùng" và mở trình bao gốc nếu không có tên người dùng nào được chỉ định. Bạn có thể sử dụng lệnh này để thay thế cho bất kỳ người dùng nào miễn là bạn biết mật khẩu.
  - Có một tệp được gọi là tệp / etc / sudoers, tệp này liệt kê những người dùng có thể chạy sudo. Có thể chỉnh sửa tệp này bằng lệnh ``` visudo ``` . 
  
- /etc/passwd
  - Hệ thống sử dụng ID người dùng (UID) để xác định người dùng. Để biết người dùng được ánh xạ tới ID nào, hãy xem tệp / etc / passwd. ``` $ cat / etc / passwd ```
  - Tệp này hiển thị danh sách người dùng và thông tin chi tiết về họ. Ví dụ: dòng đầu tiên trong tệp này rất có thể trông giống như sau:
    ```
    root:x:0:0:root:/root:/bin/bash
    ```
  - Mỗi dòng hiển thị thông tin người dùng cho một người dùng, thông thường nhất sẽ thấy người dùng root là dòng đầu tiên. Có nhiều trường được phân tách bằng dấu hai chấm cho biết thông tin bổ sung về người dùng.
    - Tên tài khoản
    - Mật khẩu người dùng
    - ID người dùng, như trên root có UID là 0
    - ID nhóm
    - GECOS : được dùng để để lại nhận xét về người dùng hoặc tài khoản 
    - Thư mục chỉnh sửa của người dùng
    - Trình bao của người dùng
  - có thể chỉnh sửa tệp / etc / passwd bằng tay nếu muốn thêm người dùng và sửa đổi thông tin bằng công cụ vipw.

- /etc/shadow
  - Tệp / etc / shadow được sử dụng để lưu trữ thông tin về xác thực người dùng. Nó yêu cầu quyền đọc siêu người dùng.
    ```
    $ sudo cat / etc / shadow
    root: MyEPTEa $ 6Nonsense: 15000: 0: 99999: 7 :::
    ```
  - Nó trông rất giống với nội dung của / etc / passwd, tuy nhiên trong trường mật khẩu, sẽ thấy một mật khẩu được mã hóa. Các trường được phân tách bằng dấu hai chấm như sau:
    - Tên tài khoản
    - Mật khẩu được mã hóa
    - Ngày thay đổi mật khẩu cuối cùng - được biểu thị bằng số ngày kể từ ngày 1/1/1970
    - Độ tuổi mật khẩu tối thiểu
    - Tuối mật khẩu tối đa
    - Khoảng thời gian cảnh báo mật khẩu
    - Khoảng thời gian không hoạt động của mật khẩu
    - Ngày hết hạn tài khoản
    - Trường dành riêng để sử dụng trong tương lai

- /etc/group  
  - Một tệp khác được sử dụng trong quản lý người dùng là tệp / etc / group. Tệp này cho phép các nhóm khác nhau với các quyền khác nhau.
    ``` $ cat /etc/group ```
  - Bao gồm các trường: ``` root:*:0:pete ```
    - Tên nhóm
    - Mật khẩu nhóm
    - ID nhóm
    - Danh sách người dùng  

- User Management Tools
  - Hầu hết các môi trường doanh nghiệp đang sử dụng hệ thống quản lý để quản lý người dùng, tài khoản và mật khẩu. Tuy nhiên, trên một máy tính đơn lẻ có các lệnh hữu ích để chạy để quản lý người dùng.
  - Thêm người dùng sử dụng lệnh adduser hoặc useradd ``` $ sudo useradd bob ```
  - Xóa người dùng sử dụng lệnh userdel ``` $ sudo userdel bob ```
  - Đổi password sử dụng ``` $ passwd bob ```

## 6. Permissions
 - File Permissions
   - Ví dụ
     ```
     $ ls -l Desktop/
     drwxr-xr-x 2 pete penguins 4096 Dec 1 11:45 .
     ```
   - Có 4 phần đối với phân quyền của tệp
     - Đầu tiên là loại tệp
     - 3 phần tiếp theo là các quyền, các quyền được nhóm thành 3 bit mỗi quyền, 3 bit đầu là quyền của người dùng, sau là quyền nhóm và cuối cùng là các quyền khác
     - ``` d | rwx | r-x | r-x ```
     - Mỗi kí tự đại diện cho mỗi quyền khác nhau: r: có thể đọc được, w: có thể ghi, x: thi hành, -: làm rỗng 
 - Modifying Permissions
   - Thay đổi quyền có thể dễ dàng thực hiện bằng lệnh ** chmod **
   - Đầu tiên, hãy chọn nhóm quyền bạn muốn thay đổi, người dùng, nhóm hoặc nhóm khác. Bạn có thể thêm hoặc xóa quyền bằng dấu + hoặc - 
   - Ví dụ : ``` $ chmod u+x myfile ``` Lệnh có nội dung như sau: thay đổi quyền trên myfile bằng cách thêm bit quyền thực thi trên tập người dùng. Vì vậy, bây giờ người dùng có quyền thực thi trên tệp này
   - Xóa bit quyền trên một tệp ``` $ chmod u-x myfile ```
   - Thêm nhiều bit quyền trên một tệp ``` $ chmod ug+w ``` .  Có một cách khác để thay đổi quyền sử dụng định dạng số. Phương pháp này cho phép bạn thay đổi các quyền cùng một lúc. Thay vì sử dụng r, w hoặc x để biểu thị các quyền, bạn sẽ sử dụng một biểu diễn số cho một tập hợp quyền duy nhất. Vì vậy, không cần chỉ định nhóm với g hoặc người dùng với u.
     - Các biểu diễn số như sau: 4: quyền đọc, 2: quyền viết, 1 quyền thực thi.
     - Ví dụ: ``` $ chmod 755 myfile ``` 
 
 - Ownership Permissions
   - Cũng có thể sửa đổi quyền sở hữu của nhóm và người dùng đối với tệp
   - Sửa đổi quyền sở hữu của người dùng ``` $ sudo chown patty myfile ``` . Lệnh sẽ đặt chủ sở hữu của mylife thành patty,
   - Sửa đổi quyền sở hữu nhóm ``` $ sudo chgrp whales myfile ``` . Lệnh sẽ đặt nhóm mylife thành whales.
   - Sửa đổi quyền sở hữu người dùng và nhóm cùng một lúc. Nếu thêm : và tên nhóm sau người dùng thì có thể đặt cả người dùng và nhóm cùng một lúc ``` $ sudo chown patty:whales myfile ```
 
 - Umask
   - Muốn thay đổi bộ quyền mặc định, có thể làm như vậy bằng lệnh umask. Lệnh này sử dụng bộ quyền 3 bit mà chúng ta thấy trong các quyền số.
   - Thay vì thêm các quyền này, umask sẽ lấy đi các quyền này ``` $ umask 021 ```
   
 - Setuid
   - Set User ID (SUID) cho phép người dùng chạy chương trình với tư cách là chủ sở hữu của tệp chương trình chứ không phải với tư cách là chính họ.
   - Sửa đổi SUID, Có 2 cách sửa đổi các quyền SUID:
     - Cách tượng trưng : ``` $ sudo chmod u+s myfile ```
     - Cách số : ``` sudo chmod 4755 myfile ```
   - SUID có ký hiệu là 4 và được cấp trước cho tập hợp quyền.  
 
 - Setgid
   - Tương tự như bit quyền ID người dùng đã đặt, có một bit quyền ID nhóm (SGID) đã đặt. Bit này cho phép một chương trình chạy như thể nó là một thành viên của nhóm đó.
   - Sửa đổi SGID 
     - Cách tượng trưng : ``` $ sudo chmod g+s myfile ```
     - Cách số : ``` $ sudo chmod 2555 myfile ```
   - SGID có số ký hiệu là 2.  
   
 - Process Permissions
   - khởi chạy một quy trình, quy trình sẽ chạy với các quyền tương tự như người dùng hoặc nhóm đã chạy nó, đây được gọi là effective user ID. UID này được sử dụng để cấp quyền truy cập cho một quy trình.    
   - Có một UID khác, được gọi là real user ID , đây là ID của người dùng đã khởi chạy quy trình. Chúng được sử dụng để theo dõi người dùng đã khởi chạy quy trình là ai.
   - Một UID cuối cùng là saved user ID, điều này cho phép quá trình chuyển đổi giữa UID hiệu quả và UID thực, ngược lại.
   
 - The Sticky Bit
   - Bit quyền này, "sticks a file/directory", điều này có nghĩa là chỉ chủ sở hữu hoặc người dùng root mới có thể xóa hoặc sửa đổi tệp. Điều này rất hữu ích cho các thư mục được chia sẻ.
   - ví dụ :
      ```
      $ ls -ld /tmp
      drwxrwxrwxt 6 root root 4096 Dec 15 11:45 /tmp
      ```
      Một bit quyền đặc biệt t ở cuối, nghĩa là mọi người đều có thể thêm tệp, ghi tệp, sửa đổi tệp trong thư mục tmp nhưng chỉ root mới có thể xóa thư mục,
   - Sửa đổi bit dính
     - Dạng tượng trưng : ``` $ sudo chmod +t mydir ```
     - Dạng số : ``` $ sudo chmod 1755 mydir ```
   - Số ký tự của bit dính là 1.
 
## 7. Processes 
 - ps (Processes)
   - Quy trình là các chương trình đang chạy trên máy của bạn. Chúng được quản lý bởi hạt nhân và mỗi tiến trình có một ID được liên kết với nó được gọi là process ID (PID). PID này được chỉ định theo thứ tự các quá trình được tạo. 
   - Chạy lệnh ps
     ```
     $ ps
     PID TTY STAT TIME CMD
     41230 pts / 4 S 00:00:00 bash
     51224 pts / 4 R + 00:00:00 ps
     ```
     PID : ID quy trình
     TTY : kiểm soát thiết bị đầu cuối liên quan đến quy trình
     STAT: Mã trạng thái quy trình
     TIME: Tổng thời gian sử dụng CPU
     CMD : Tên của lệnh (Lệnh thực thi)
   - Lệnh ``` $ ps aux ``` , a : các quá trình đang chạy, u : hiển thị chi tiết hơn các quy trình, x : liệt kê các quy trình không có TTY liên kết với nó, các quy trình này sẽ hiển thị ? trong trường TTY.
   - Lệnh ``` $ top ``` , cung cấp thông tin thời gian thực về các tiến trình đang chạy trên hệ thống, theo mặc định thì sẽ được làm mới sau mỗi 10s.
   
 - Controlling Terminal
   - TTY là thiết bị đầu cuối thực hiện lệnh.
   - Có 2 loại thiết bị đầu cuối
     - terminal devices: là thiết bị đầu cuối nguyên bản có thể nhập và gửi đàu ra tới hệ thống.
     - pseudoterminal devices: mô phỏng các thiết bị đầu cuối với cửa sổ đầu cuối shell và được ký hiệu là PTS.
   - Các quy trình thường bị ràng buộc với một thiết bị đầu cuối điều khiển. 
   - Trong đầu ra ps, TTY được liệt kê là ? nghĩa là nó không có thiết bị đầu cuối điều khiển.
   
 - Process Details 
   - Kernel phụ trách các quá trình, khi chạy một chương trình, hạt nhân sẽ tải mã của chương trình đó vào bộ nhớ, xác định và phân bổ tài nguyên rồi giữ các tab trên mỗi quá trình, nó biết:
     - Tình trạng của quá trình
     - Các tài nguyên mà quá trình đang sử dụng và nhận được
     - Chủ sở hữu quy trình
     - Xử lí tín hiệu
     - Mọi thứ khác
   - Công việc của kernel là đảm bảo rằng các quy trình nhận được lượng tài nguyên phù hợp tùy thuộc vào nhu cầu của quy trình. Khi một quá trình kết thúc, các tài nguyên mà nó đã sử dụng sẽ được giải phóng cho các quá trình khác.
   
 - Process Creation
   - Khi một quy trình mới được tạo, một quy trình hiện tại về cơ bản sẽ tự sao chép bằng cách sử dụng một thứ gọi là lệnh gọi hệ thống rẽ nhánh.
   - Lệnh gọi hệ thống rẽ nhánh tạo ra một quy trình con gần như giống hệt nhau, quy trình con này nhận một ID quy trình mới (PID) và quy trình gốc trở thành quy trình mẹ của nó và có một cái gì đó được gọi là ID quy trình mẹ PPID.
   - Tiến trình con có thể tiếp tục sử dụng cùng một chương trình mà cha mẹ của nó đã sử dụng trước đó hoặc thường xuyên hơn sử dụng lệnh gọi hệ thống thực thi để khởi chạy một chương trình mới.     
   - Lệnh gọi hệ thống này phá hủy việc quản lý bộ nhớ mà hạt nhân đưa vào cho quá trình đó và thiết lập các bộ nhớ mới cho chương trình mới.
     ```
     $ ps l
     ```
   - Tùy chọn l cung cấp chế độ xem định dạng dài, chi tiết hơn về các quy trình đang chạy. Cột có nhãn PPID là ID mẹ.
   - Khi hệ thống khởi động, các hạt nhân tạo ra một tiến trình gọi là init , nó có PID là 1. Tiến trình init không thể kết thúc trừ khi hệ thống tắt. Nó chạy với đặc quyền root và chạy nhiều quy trình giúp hệ thống luôn hoạt động.
   
 - Process Termination
   - Một quy trình có thể thoát bằng lệnh gọi hệ thống exit , điều này sẽ giải phóng tài nguyên mà quy trình đang sử dụng để phân bổ lại. Vì vậy, khi một tiến trình sẵn sàng kết thúc, nó sẽ cho hạt nhân biết lý do tại sao nó kết thúc với một thứ gọi là trạng thái kết thúc. Thông thường nhất, trạng thái 0 có nghĩa là quá trình đã thành công. Tuy nhiên, điều đó không đủ để chấm dứt hoàn toàn một quá trình. Tiến trình mẹ phải xác nhận việc kết thúc quy trình con bằng cách sử dụng lệnh gọi của hệ thống chờ và điều này làm là nó kiểm tra trạng thái kết thúc của quy trình con. 
   - Orphan Processes: Khi tiến trình cha chết trước tiến trình con, kernel biết sẽ không nhận được lệnh chờ nó sẽ biến các tiến trình này thành orphan và đặt chúng cho init chăm sóc. Init sẽ thực hiện lệnh gọi của hệ thống chờ những tiến trình orphan này có thế chết.
   - Zombie Processes: Mặc dù tiến trình con kết thúc nhưng hạt nhân sẽ biến các tiến trình con này thành một quá trình zombie, các tài nguyên tiến trình con sử dụng vẫn được giải phóng cho tiến trình khác. Zombie processes không thể bị giết vì có thể hiểu chúng đã chết về mặt kỹ thuật. Cuối cùng nếu tiến trình cha gọi lệnh chờ hệ thống, thây ma sẽ biến mất, điều này được gọi là "gặt hái". Nếu cha mẹ không thực hiện cuộc gọi chờ, init sẽ chấp nhận zombie và tự động thực hiện chờ và loại bỏ zombie.
   
 - Signals
   - Tín hiệu là một thông báo cho một quá trình rằng điều gì đó đã xảy ra.
   - Lí do có tín hiệu
     - Người dùng có thể nhập một trong các ký tự đầu cuối đặc biệt hoặc để hủy, ngắt hoặc tạm dừng các tiến trình
     - Sự cố phần cứng có thể xảy ra và hạt nhân muốn thông báo quá trình
     - Sự cố về phần mềm có thể xảy ra và hạt nhân muốn thông báo quá trình
     - Là những cách mà quy trình có thể giao tiếp
   - Quy trình tín hiệu
     - Tín hiệu được tạo ra bởi một số sự kiện sau đó được chuyển đến một quá trình, được gọi là trạng thái chờ xử lí cho đến khi được phân phối. Khi quá trình được chạy, tính hiệu sẽ được phân phối. Tuy nhiên, các quy trình có mặt nạ tín hiệu và chúng có thể đặt việc phân phối tín hiệu bị chặn nếu được chỉ định. Khi một tín hiệu được phân phối, một quá trình có thể thực hiện vô số việc:
       - Bỏ qua tín hiệu
       - Bắt tín hiệu và thực hiện 1 quy trình xử lý cụ thể
       - Quá trình có thể được kết thúc, trái ngược với lệnh gọi hệ thống thoát bình thường.
       - Chặn tín hiệu, tùy thuộc vào mặt nạ tín hiệu
   - Tín hiệu chung
     - Mỗi tín hiệu được xác định bởi các số nguyên có tên tượng trưng có dạng SIGxxx
     - Một số tín hiệu phổ biến
       - SIGHUP hoặc HUP hoặc 1: Cúp máy
       - SIGINT hoặc INT hoặc 2: Ngắt
       - SIGKILL hoặc KILL hoặc 9: Giết
       - SIGSEGV hoặc SEGV hoặc 11: Lỗi phân đoạn
       - SIGTERM hoặc TERM hoặc 15: Chấm dứt phần mềm
       - SIGSTOP hoặc STOP: Dừng lại 
     - Một số tín hiệu không thể chặn được, một ví dụ là tín hiệu SIGKILL. Tín hiệu KILL phá hủy quá trình. 
 
 - kill (Terminate)
   - Có thể gửi các tín hiệu kết thúc quá trình, một lệnh như vậy được đặt tên hợp lý là lệnh kill. ``` $ kill 12445 ``` ,1 2445 là PID của quá trình bạn muốn kết thúc.
   - Có thể chỉ định một tính hiệu bằng lệnh kill ``` $ kill -9 12445 ```
   - Sự khác nhau giữa SIGHUP, SIGINT, SIGTERM, SIGKILL, SIGSTOP
     - SIGHUP - Cúp máy, được gửi tới một quy trình khi thiết bị đầu cuối điều khiển đóng.
     - SIGINT - Là một tín hiệu ngắt, vì vậy bạn có thể sử dụng Ctrl-C và hệ thống sẽ cố gắng kết thúc quá trình một cách nhẹ nhàng.
     - SIGTERM - Hủy quá trình, nhưng cho phép nó thực hiện một số hoạt động dọn dẹp trước.
     - SIGKILL - Giết quá trình, giết nó bằng lửa, không thực hiện bất kỳ hoạt động dọn dẹp nào.
     - SIGSTOP - Dừng / tạm ngừng quá trình.
 
 - niceness
   - Các quy trình sử dụng CPU trong một khoảng thời gian nhỏ được gọi là lát thời gian. Sau đó, chúng tạm dừng trong mili giây và một quá trình khác nhận được một lát thời gian nhỏ. Theo mặc định, lập lịch quy trình diễn ra theo kiểu tuần hoàn này. Mọi quy trình đều có đủ thời gian cho đến khi xử lý xong. Kernel xử lý tất cả các quá trình chuyển đổi này và nó thực hiện khá tốt công việc đó trong hầu hết thời gian.
   - Niceness là các tiến trình có một số để xác định mức độ ưu tiên của chúng đối với CPU. Một số cao có nghĩa là quá trình tốt và có mức độ ưu tiên thấp hơn cho CPU và số thấp hoặc âm có nghĩa là quá trình không tốt lắm và nó muốn lấy càng nhiều CPU càng tốt.
   - Để thay đổi mức độ ta sử dụng lệnh nice hoặc renice
     - ``` $ nice -n 5 apt upgrade ```
     - ``` $ renice 10 -p 3245 ```
     - Lệnh nice được sử dụng để đặt mức độ ưu tiên cho một tiến trình mới. Lệnh renice được sử dụng để đặt mức độ ưu tiên trên một quy trình hiện có.
 
 - Process States
   - Xem lệnh ``` $ ps aux ```
   - Trong cột STAT sẽ thấy rất nhiều giá trị, các mã trạng thái phổ biến nhất là:
     - R: đang chạy hoặc có thể chạy được, nó chỉ chờ CPU xử lý thôi
     - S: Chế độ ngủ gián đoạn, chờ một sự kiện hoàn thành, chẳng hạn như đầu vào từ thiết bị đầu cuối
     - D: Ngủ liên tục, các quá trình không thể bị giết hoặc bị gián đoạn bằng tín hiệu, thường để làm cho chúng biến mất, bạn phải khởi động lại hoặc khắc phục sự cố
     - Z: Zombie, chúng ta đã thảo luận trong một bài học trước rằng zombie là những tiến trình đã kết thúc đang chờ thu thập trạng thái của chúng
     - T: Đã dừng, một quá trình đã bị tạm dừng / dừng
 
 - /proc filesystem
   - Thông tin quy trình được lưu trữ trong một hệ thống tệp đặc biệt được gọi là hệ thống tệp / proc. ``` $ ls /proc ```
   - ``` $ cat /proc/12345/status ``` thông tin trạng thái quy trình và thông tin chi tiết hơn. Thư mục / proc là cách kernel xem hệ thống, vì vậy có rất nhiều thông tin ở đây hơn những gì bạn sẽ thấy trong ps.
   
 - Job Control
   - Gửi một công việc đến nền bằng cách thêm dấu & vào lệnh sẽ chạy ở chế độ nền để vẫn có thể sử dụng cửa sổ lệnh:
     ```
     $ sleep 1000 &
     $ sleep 1001 &
     $ sleep 1002 &
     ```
   - Xem các công việc nền
     ```
     $ jobs
     [1]    Running     sleep 1000 &
     [2]-   Running     sleep 1001 &
     [3]+   Running     sleep 1002 &
     ```
     Thao tác này sẽ hiển thị id công việc trong cột đầu tiên, sau đó là trạng thái và lệnh đã được chạy. Dấu + bên cạnh ID công việc có nghĩa là nó là công việc nền gần đây nhất đã bắt đầu. Công việc với - là lệnh gần đây nhất thứ hai.
   - Gửi một công việc đến nền trên công việc hiện có, nếu đã chạy một công việc và muốn gửi nó xuống nền, bạn không cần phải chấm dứt nó và bắt đầu lại. Trước tiên, hãy tạm dừng công việc bằng Ctrl-Z, sau đó chạy lệnh ``` bg ``` để gửi nó xuống nền.
   - Di chuyển công việc từ nền sang nền trước ``` $ fg %1 ```
   - Giết công việc nền ``` kill %1 ```
## 8. Packages   
 - Software Distribution
   - Hệ thống bao gồm nhiều gói như trình duyệt, trình soạn thảo, trình phát đa phương tiện,.. Các gói này sẽ được quản lý thông qua trình quản lý gói để cài đặt và duy trì phần mềm trên hệ thống.
   - Thường có thể cài đặt trực tiếp từ mã nguồn, nhưng phần lớn là sử dụng trình quản lý gói để cài đặt, các gói phổ biến là Debian (.deb), Red Hat (.rpm).
   - Những người viết các phần mềm được gọi là upstream providers, họ biên dịch mã và viết cách cài đặt, họ làm việc để đưa ra các phiên bản, phần mềm mới. Khi đã sẵn sàng phát hành, họ gửi gói tới package maintainers, những người này sẽ xử lý và đưa phần mềm tới người dùng, xem xét và quản lý phàn mềm này dưới dạng gói.
    
 - Package Repositories
   - Kho lưu trữ chỉ là một vị trí lưu trữ trung tâm cho các gói. Có rất nhiều kho chứa rất nhiều gói và tốt nhất là tất cả chúng đều được tìm thấy trên internet, không có đĩa cài đặt.
   - Thay vì truy cập trang web để tải xuống, chúng ta có thể yêu cầu máy tính tìm phần mềm từ liên kết nguồn.
   - Bản phân phối đã đi kèm với các nguồn được phê duyệt trước để lấy các gói và đây là cách nó cài đặt tất cả các gói cơ sở mà chúng ta thấy trên hệ thống của mình. Trên hệ thống Debian, tệp nguồn này là tệp /etc/apt/sources.list .
  
 - tar and gzip
   - gzip là chương trình được sử dụng để nén các tệp trong linux, chúng kết thúc bằng phần mở rộng ``` .gz ```
     - Nén tệp: ``` $ gzip mycoolfile ```
     - Giải nén: ``` $ gunzip mycoolfile.gz ```
   - gzip sẽ không thể thêm nhiều tệp vào 1 kho lưu trữ, thay vì đó chúng ta sẽ sử dụng tar. Kho lưu trữ tar sẽ có phần mở rộng .tar
     - Tạo tệp lưu trữ bằng tar ``` $ tar cvf mytarfile.tar mycoolfile1 mycoolfile2 ```
       - c: tạo
       - v: yêu cầu chương trình cho xem chúng đang làm gì
       - f: tên tệp của tệp tar phải đứng sau tùy chọn này 
     - Giải nén kho lưu trữ bằng tar ``` $ tar xvf mytarfile.tar ```
       - x: trích xuất
       - v: yêu cầu chương trình cho xem chúng đang làm gì
       - f: tệp muốn giải nén
     - Nén và giải nén các kho lưu trữ bằng tar và gzip
       - Tạo tệp tar nén: ``` $ tar czf myfile.tar.gz ```
       - Giải nén: ``` $ tar xzf file.tar ```
 
 - Package Dependencies
   - Các gói rất hiếm khi tự hoạt động, chúng thường đi kèm với các gói phụ thuộc để giúp chúng chạy.
   - Trong Linux, các phần phụ thuộc này thường là các gói khác hoặc các thư viện được chia sẻ. Thư viện dùng chung là thư viện mã mà các chương trình khác muốn sử dụng và không muốn phải viết lại cho chính mình.
   - Các gói có các phần phụ thuộc để giúp chúng chạy, cho dù các phần phụ thuộc đó là các gói hay thư viện khác, nếu các phần phụ thuộc không có ở đó thì gói sẽ bị hỏng trạng thái và hầu hết thời gian thậm chí không cài đặt. 
  
 - rpm and dpkg
   - Để cài đặt các gói trực tiếp này, có thể sử dụng các lệnh quản lý gói: rpm và dpkg. 
   - Sẽ không cài đặt các gói phụ thuộc, do vậy nếu gói có phụ thuộc thì sẽ cần cài đặt các gói riêng lẻ và sau đó là các phần phụ thuộc.
   - Cài đặt gói:
     - Debian: $ dpkg -i some_deb_package.deb
     - RPM: $ rpm -i some_rpm_package.rpm
       - i là viết tắt của install (cài đặt)   
   - Xóa gói:
     - Debian: $ dpkg -i some_deb_package.deb
     - RPM: $ rpm -e some_rpm_package.rpm
       - Debian: r để xóa
       - RPM: e để xóa
   - Liệt kê các gói đã cài đặt:
     - Debian: $ dpkg -l
     - RPM: $ rpm -qa
       - Debian: l là cho danh sách
       - RPM: q cho truy vấn và a là cho tất cả  
      
 - yum and apt
   - Các hệ thống đi kèm với tất cả các bản sửa lỗi để làm cho việc cài đặt, gỡ bỏ và thay đổi gói dễ dàng hơn, bao gồm cả việc cài đặt các gói phụ thuộc. Hai trong số các hệ thống quản lý phổ biến nhất là yum và apt . Yum dành riêng cho dòng Red Hat và apt dành riêng cho dòng Debian.
   - Cài đặt một gói từ kho lưu trữ:
     - Debian: $ apt install package_name
     - RPM: $ yum install package_name
   - Loại bỏ một gói:
     - Debian: $ apt remove package_name
     - RPM: $ yum erase package_name 
   - Cập nhật các gói cho một kho lưu trữ:
     - Debian: apt update; apt upgrade
     - RPM: yum update
   - Nhận thông tin về một gói đã cài đặt:
     - Debian: apt show package_name
     - RPM: yum info package_name      
 
 - Compile Source Code
   - Thông thường, sẽ gặp phải một gói khó hiểu chỉ xuất hiện dưới dạng mã nguồn thuần túy. Chúng ta sẽ cần sử dụng một số lệnh để gói mã nguồn đó được biên dịch và cài đặt trên hệ thống.
   - Đầu tiên sẽ cần có phần mềm để cài đặt các công cụ cho phép biên dịch mã nguồn: 
     ``` $ sudo apt install build-essential ```
   - Sau đó giải nén nội dung của tệp gói
     ``` $ tar -xzvf package.tar.gz ```
   - Trước khi làm gì đó hãy xem tệp README để xem hướng dẫn cài đặt cụ thể.
   - Bên trong nội dung gói sẽ là tập lệnh cấu hình, tập lệnh này kiểm tra các phần phụ thuộc vào hệ thống và nếu thiếu bất kỳ điều gì chúng ta sẽ thấy lỗi và cần phải sửa chúng. ``` $ ./configure ```, ``` ./ ``` cho phép thực thi tập lệnh trong thư mục hiện tại.
   - ``` $ make ```, bên trong nội dung gói sẽ có tệp Makefile chứa các quy tắc để xây dựng phần mềm, và khi chạy lệnh make thì nó sẽ xem tệp này để xây dựng phần mềm.
   - Lệnh để cài đặt gói, nó sẽ sao chép các tệp chính xác vào đúng vị trí trên máy tính. ``` $ sudo make install ```
   - Để gỡ cài đặt sử dụng lệnh ``` $ sudo make uninstall ```
   - Để có thể dễ dàng trong việc gỡ cài đặt và cài đặt hãy sử dụng lệnh ``` $ sudo checkinstall ```. Lệnh này sẽ thực hiện và xây dựng gói .deb và cài đặt nó để giúp dễ dàng cho việc gỡ các gói sau này.
 
## 9. Devices 
 - /dev directory
   - Khi kết nối một thiết bị với máy của mình, nó thường cần một trình điều khiển thiết bị để hoạt động bình thường. Bạn có thể tương tác với trình điều khiển thiết bị thông qua tệp thiết bị hoặc nút thiết bị, đây là những tệp đặc biệt trông giống như tệp thông thường.
   - Các tệp thiết bị này thường được lưu trữ trong thư mục /dev. Hãy tiếp tục và chọn thư mục / dev trên hệ thống, sẽ thấy một lượng lớn các tệp thiết bị có trong hệ thống. 
     ``` $ ls /dev ```
   - Khi gửi đầu ra đến /dev/null, kernel biết rằng thiết bị này lấy tất cả dữ liệu đầu vào và chỉ loại bỏ nó nên sẽ không có gì được trả lại.
 
 - device types
   - Có lệnh sau:
     ```
     $ ls -l /dev
     brw-rw----   1 root disk      8,   0 Dec 20 20:13 sda
     crw-rw-rw-   1 root root      1,   3 Dec 20 20:13 null
     srw-rw-rw-   1 root root           0 Dec 20 20:13 log
     prw-r--r--   1 root root           0 Dec 20 20:13 fdata
     ``` 
   - Từ trái sang phải tương ứng các cột như sau: quyền, người sở hữu, nhóm, số thiết bị chính, số thiết bị phụ, dấu thời gian, tên thiết bị.
   - Trong lệnh ls có thể thấy loại tệp với bit đầu tiên trên mỗi dòng, các tệp thiết bị được biễn thị:
     - c: ký tự
     - b: khối
     - p: pipe
     - s: socket 
   - Thiết bị ký tự
     - Các thiết bị này truyền dữ liệu và mỗi lần một ký tự, sẽ thấy rất nhiều thiết bị giả dưới dạng thiết bị ký tự, những thiết bị này không thực sự được kết nối vật lý với máy, nhưng chúng cho phép hệ điều hành có nhiều chức năng hơn.
   - Chặn thiết bị
     - Các thiết bị này truyền dữ liệu, nhưng trong các khối có kích thước cố định lớn. Sẽ thường thấy các thiết bị sử dụng khối dữ liệu làm thiết bị khối, chẳng hạn như ổ cứng, hệ thống tệp, v.v.
   - Thiết bị đường ống (pipe)
     - Các đường ống được đặt tên cho phép hai hoặc nhiều quy trình giao tiếp với nhau, chúng tương tự như các thiết bị ký tự, nhưng thay vì có đầu ra được gửi đến một thiết bị, nó được gửi đến một quy trình khác.
   - Thiết bị ổ cắm (socket)
     - Thiết bị ổ cắm tạo điều kiện giao tiếp giữa các quy trình, tương tự như thiết bị đường ống nhưng chúng có thể giao tiếp với nhiều quy trình cùng một lúc.
   - Đặc tính thiết bị
     - Các thiết bị được đặc trưng bằng cách sử dụng hai số, số thiết bị chính và số thiết bị phụ.
     - Trong ví dụ ls ở trên, chúng được phân tách bằng dấu phẩy. Ví dụ: giả sử một thiết bị có số thiết bị: 8, 0.
 
 - Device Names
   - Thiết bị SCSI: SCSI là viết tắt của Small Computer System Interface, nó là một giao thức được sử dụng để cho phép giao tiếp giữa đĩa, máy in, máy quét và các thiết bị ngoại vi khác với hệ thống. Hệ thống Linux tương ứng với đĩa SCSI với ổ đĩa cứng trong /dev. Chúng được thể hiện bằng tiền tố sd (đĩa SCSI): 
     - /dev/sda - Đĩa cứng đầu tiên
     - /dev/sdb - Đĩa cứng thứ hai
     - /dev/sda3 - Phân vùng thứ ba trên đĩa cứng đầu tiên
   - Thiết bị giả: thiết bị giả không thực sự được kết nối vật lý với hệ thống, hầu hết các thiết bị giả phổ biến là thiết bị ký tự:
     - /dev/zero - chấp nhận và loại bỏ tất cả đầu vào, tạo ra một luồng byte giá trị null liên tục
     - /dev/null - chấp nhận và loại bỏ tất cả đầu vào, không tạo ra đầu ra
     - /dev/random - tạo ra các số ngẫu nhiên
   - Thiết bị PATA: ổ cứng được tham chiếu với tiền tố hd
     - /dev/hda - đĩa cứng đầu tiên
     - /dev/hdd2 - phân vùng thứ hai trên đĩa cứng thứ 4
 
 - sysfs
   - Sysfs đã được tạo ra từ lâu để quản lý tốt hơn các thiết bị trên hệ thống mà thư mục /dev không làm được.
   - Sysfs là một hệ thống tập tin ảo, thường được gắn vào thư mục /sys.
   - Nó cung cấp cho nhiều thông tin chi tiết hơn những gì có thể thấy trong thư mục /dev. 
   - Cả hai thư mục /sys và /dev dường như rất giống nhau và chúng giống nhau về mặt nào đó, nhưng chúng có những điểm khác biệt lớn. Về cơ bản, thư mục /dev rất đơn giản, nó cho phép các chương trình khác tự truy cập vào thiết bị, trong khi hệ thống tập tin /sys được sử dụng để xem thông tin và quản lý thiết bị.
   - Hệ thống tệp /sys về cơ bản chứa tất cả thông tin cho tất cả các thiết bị trên hệ thống, chẳng hạn như nhà sản xuất và kiểu máy, nơi thiết bị được cắm vào, trạng thái của thiết bị, phân cấp thiết bị và hơn thế nữa. Các tệp bạn thấy ở đây không phải là các nút thiết bị, vì vậy không thực sự tương tác với các thiết bị từ thư mục /sys, thay vì đang quản lý thiết bị.
 
 - udev
   - ``` $ mknod /dev/sdb1 b 8 3 ``` lệnh tạo một nút thiết bị /dev/sdb1 và sẽ làm cho nó trở thành thiết bị khối b với số chính là 8 và số phụ là 3.
   - Để xóa thiết bị chỉ cần rm tệp thiết bị trong thư mục /dev.
   - Hệ thống udev sẽ tự động tạo và xóa tệp thiết bị tùy thuộc vào việc chúng có được kết nối hay không. 
   - Có udevd đang chạy trên hệ thống và lắng nghe các thông báo từ kernel về các thiết bị được kết nối với hệ thống, udevd sẽ phân tích cú pháp thông tin đó và sẽ khớp dữ liệu với các quy tắc được chỉ định trong /etc/udev/rules.d.
   - Có thể xem cơ sở dữ liệu udev và sysfs bằng lệnh udevadm.
   
 - lsusb, lspci, lssci
   - Đây là các công cụ để liệt kê thông tin về thiết bị
   - Liệt kê các thiết bị usb: ``` lsusb ```
   - Liệt kê các thiết bị PCI: ``` lspci ```
   - Liệt kê các thiết bị SCSI: ``` lsscsi ```
   
 - dd
   - Công cụ dd rất hữu ích để chuyển đổi và sao chép dữ liệu. Nó đọc đầu vào từ một tệp hoặc luồng dữ liệu và ghi nó vào một tệp hoặc luồng dữ liệu.
   ``` $ dd if=/home/pete/backup.img of=/dev/sdb bs=1024 ```
   Lệnh đang sao chép nội dung của backup.img sang /dev/sdb, sao chép dữ liệu theo khối 1024 byte cho đến khi không còn dữ liệu nào được sao chép.
     - if = file : tệp đầu vào đọc từ tệp thay vì đầu vào chuẩn
     - of = file : tệp đầu ra, ghi vào tệp thay vì đầu ra tiêu chuẩn
     - bs = byte : kích thước khối, đọc và ghi nhiều byte dữ liệu này cùng lúc.
     - count = number : số khối cần sao chép 
   - Một số lệnh dd sử dụng tùy chọn đếm, thường với dd nếu muốn sao chép tệp có dung lượng 1 megabyte.
   - dd cực kỳ mạnh mẽ, có thể sử dụng nó để sao lưu mọi thứ, bao gồm toàn bộ ổ đĩa, khôi phục hình ảnh đĩa và hơn thế nữa. 
 
## 10. The Filesystem
 - Filesystem Hierarchy
   - Thực hiện lệnh ls -l / để xem các thư mục được liệt kê trong thư mục gốc:
     - / - Thư mục gốc của toàn bộ hệ thống tập tin phân cấp, mọi thứ đều nằm trong thư mục này.
     - /bin - Các chương trình sẵn sàng chạy cần thiết (mã nhị phân), bao gồm các lệnh cơ bản nhất như ls và cp.
     - /boot - Chứa các tệp bộ tải khởi động hạt nhân.
     - /dev - Tệp thiết bị.
     - /etc - Thư mục cấu hình hệ thống cốt lõi, chỉ nên chứa các tệp cấu hình chứ không phải bất kỳ tệp nhị phân nào.
     - /home - Thư mục cá nhân cho người dùng, lưu giữ tài liệu, tệp, cài đặt của bạn, v.v.
     - /lib - Chứa các tệp thư viện mà các tệp nhị phân có thể sử dụng.
     - /media - Được sử dụng làm điểm đính kèm cho phương tiện di động như ổ USB.
     - /mnt - Hệ thống tệp được gắn kết tạm thời.
     - /opt - Các gói phần mềm ứng dụng tùy chọn.
     - /proc - Thông tin về các quy trình hiện đang chạy.
     - /root - Thư mục chính của người dùng root.
     - /run - Thông tin về hệ thống đang chạy kể từ lần khởi động cuối cùng.
     - /sbin - Chứa các tệp nhị phân hệ thống thiết yếu, thường chỉ có thể chạy bằng root.
     - /srv - Dữ liệu dành riêng cho trang web được hệ thống cung cấp.
     - /tmp - Bộ nhớ cho các tệp tạm thời
     - /usr - Thật không may, nó được đặt tên, hầu hết nó không chứa các tệp người dùng theo nghĩa là một thư mục chính. Điều này có nghĩa là dành cho phần mềm và tiện ích do người dùng cài đặt, tuy nhiên điều đó không có nghĩa là bạn không thể thêm thư mục cá nhân vào đó. Bên trong thư mục này là các thư mục con cho /usr/bin, /usr/local, v.v.
     - /var - Thư mục biến, nó được sử dụng để ghi nhật ký hệ thống, theo dõi người dùng, bộ nhớ đệm, v.v. Về cơ bản, bất kỳ thứ gì có thể thay đổi liên tục. 
     
 - Filesystem Types
   - Viết nhật ký:
     - Việc ghi nhật ký được mặc định trên hầu hết các loại hệ thống tệp, nhưng đề phòng trường hợp không có, chúng ta nên biết chức năng của nó. Giả sử chúng ta đang sao chép một tệp lớn và đột nhiên bạn bị mất điện. 
     - Nếu chúng ta đang sử dụng hệ thống tệp không được ghi nhật ký, tệp sẽ bị hỏng và hệ thống tệp của bạn sẽ không nhất quán và sau đó khi khởi động lại, hệ thống của sẽ thực hiện kiểm tra hệ thống tệp để đảm bảo mọi thứ đều ổn. Tuy nhiên, việc sửa chữa có thể mất một lúc tùy thuộc vào dung lượng hệ thống tệp.
     - Bây giờ nếu đang ở trên một hệ thống ghi nhật ký, trước khi máy bắt đầu sao chép tệp, nó sẽ ghi những gì chúng ta sẽ làm vào một tệp nhật ký (nhật ký). 
     - Bây giờ khi chúng ta thực sự sao chép tệp, sau khi nó hoàn thành, nhật ký sẽ đánh dấu nhiệm vụ đó là hoàn thành. 
     - Hệ thống tập tin luôn ở trạng thái nhất quán vì điều này, vì vậy nó sẽ biết chính xác nơi đã dừng lại nếu máy tắt đột ngột. Điều này cũng làm giảm thời gian khởi động vì thay vì kiểm tra toàn bộ hệ thống tệp, nó chỉ xem nhật ký.
   - Các loại hệ thống tập tin máy tính để bàn phổ biến:
     - ext4 - Đây là phiên bản mới nhất của hệ thống tệp Linux gốc. Nó tương thích với các phiên bản ext2 và ext3 cũ hơn. Nó hỗ trợ khối lượng đĩa lên đến 1 exabyte và kích thước tệp lên đến 16 terabyte và hơn thế nữa. Nó là sự lựa chọn tiêu chuẩn cho các hệ thống tập tin Linux.
     - Btrfs - "Better or Butter FS" là một hệ thống tệp mới dành cho Linux đi kèm với các ảnh chụp nhanh, sao lưu gia tăng, tăng hiệu suất và hơn thế nữa. Nó được cung cấp rộng rãi, nhưng chưa hoàn toàn ổn định và tương thích.
     - XFS - Hệ thống tệp nhật ký hiệu suất cao, tuyệt vời cho hệ thống có các tệp lớn như máy chủ đa phương tiện.
     - NTFS và FAT - Hệ thống tệp Windows
     - HFS + - Hệ thống tệp Macintosh
   - Lệnh df báo cáo việc sử dụng không gian đĩa hệ thống tệp và các chi tiết khác về đĩa.
 
 - Anatomy of a Disk
   - Đĩa cứng có thể được chia nhỏ thành các phân vùng, về cơ bản tạo ra nhiều thiết bị khối.
   - Phân vùng cực kỳ hữu ích để phân tách dữ liệu và nếu bạn cần một hệ thống tệp nhất định.
   - Bảng phân vùng: 
     - Mỗi đĩa sẽ có một bảng phân vùng, bảng này cho hệ thống biết cách phân vùng của đĩa. 
     - Bảng này cho biết nơi bắt đầu và kết thúc của các phân vùng, những phân vùng nào có thể khởi động được, những thành phần nào của đĩa được cấp cho phân vùng nào, v.v. Có hai lược đồ bảng phân vùng chính được sử dụng, Master Boot Record (MBR) và GUID Partition Table (GPT)
   - Vách ngăn:
     - Đĩa bao gồm các phân vùng giúp chúng ta tổ chức dữ liệu của mình. 
     - Có thể có nhiều phân vùng trên một đĩa và chúng không thể chồng lên nhau.
     - Nếu có không gian không được phân bổ cho một phân vùng, thì nó được gọi là không gian trống.
     - MBR:
       - Bảng phân vùng truyền thống, được sử dụng làm tiêu chuẩn
       - Có thể có phân vùng chính, mở rộng và phân vùng logic
       - MBR có giới hạn là bốn phân vùng chính
       - Có thể tạo phân vùng bổ sung bằng cách tạo phân vùng chính thành phân vùng mở rộng (chỉ có thể có một phân vùng mở rộng trên đĩa). Sau đó, bên trong phân vùng mở rộng, thêm các phân vùng hợp lý. Các phân vùng hợp lý được sử dụng giống như bất kỳ phân vùng nào khác.
       - Hỗ trợ đĩa lên đến 2 terabyte
     - GPT:
       - Bảng phân vùng GUID (GPT) đang trở thành tiêu chuẩn mới để phân vùng đĩa
       - Chỉ có một loại phân vùng và bạn có thể tạo nhiều phân vùng trong số đó
       - Mỗi phân vùng có một ID duy nhất trên toàn cầu (GUID)
       - Được sử dụng chủ yếu cùng với khởi động dựa trên UEFI
   - Cấu trúc hệ thống tập tin
     - Khối khởi động - Khối này nằm trong một vài sector đầu tiên của hệ thống tệp và nó không thực sự được hệ thống tệp sử dụng. Đúng hơn, nó chứa thông tin được sử dụng để khởi động hệ điều hành. Hệ điều hành chỉ cần một khối khởi động. Nếu bạn có nhiều phân vùng, chúng sẽ có các khối khởi động, nhưng nhiều trong số chúng không được sử dụng.
     - Siêu khối - Đây là một khối đơn lẻ nằm sau khối khởi động và nó chứa thông tin về hệ thống tệp, chẳng hạn như kích thước của bảng inode, kích thước của các khối logic và kích thước của hệ thống tệp.
     - Bảng Inode - Hãy coi đây là cơ sở dữ liệu quản lý các tệp của chúng ta (chúng ta có cả một bài học về inode, vì vậy đừng lo lắng). Mỗi tệp hoặc thư mục có một mục nhập duy nhất trong bảng inode và nó có nhiều thông tin khác nhau về tệp.
     - Khối dữ liệu - Đây là dữ liệu thực tế cho các tệp và thư mục. 
 
 - Disk Partitioning
   - Có nhiều công cụ có sẵn để thực hiện việc phân vùng ổ đĩa:
     - fdisk - công cụ phân vùng dòng lệnh cơ bản, nó không hỗ trợ GPT
     - parted - đây là một công cụ dòng lệnh hỗ trợ cả phân vùng MBR và GPT
     - gparted - đây là phiên bản GUI của parted
     - gdisk - fdisk, nhưng nó không hỗ trợ MBR chỉ GPT
   - Sử dụng parted để thực hiện phân vùng 
     - Khởi chạy: ``` sudo parted ```
     - Chọn thiết bị: ``` select /dev/sdb2 ```
     - Xem bảng phân vùng: 
       ```
       (parted) print                                                            
         Model: Seagate (scsi)
         Disk /dev/sda: 21.5GB
         Sector size (logical/physical): 512B/512B
         Partition Table: msdos
         Number  Start   End     Size    Type      File system     Flags
         1      1049kB  6860MB  6859MB  primary   ext4            boot
         2      6861MB  21.5GB  14.6GB  extended
         5      6861MB  7380MB  519MB   logical   linux-swap(v1)
         6      7381MB  21.5GB  14.1GB  logical   xfs
        ```
      - Phân vùng thiết bị: ``` mkpart primary 123 4567 ```
      - Thay đổi kích thước phân vùng: ``` resize 2 1245 3456 ```
  
  - Creating Filesystems
    - Tạo hệ thống tập tin bằng lệnh ``` sudo mkfs -t ext4 /dev/sdb2 ```
    - mkfs cho phép chỉ định loại hệ thống têp chúng ta muốn và nơi chúng ta muốn nó.
    
  - mount and umount
    - Trước khi có thể xem nội dung của hệ thống tệp thì sẽ phải gắn kết nó. Để làm điều đó sẽ cần vị trí thiết bị, loại hệ thống tệp và điểm gắn kết.
    - Điểm gắn kết là một thư mục trên hệ thống nơi hệ thống tệp sẽ được đính kèm.
    - Tạo điểm gắn kết ``` sudo mount -t ext4 /dev/sdb2 /mydrive ```, -t là chỉ định loại hệ thống tệp tiếp theo là vị trí thiết bị và cuối cùng là điểm gắn kết.
    - Để ngắt kết nối thiết bị và điểm gắn kết ``` sudo umount /mydrive ``` hoặc ``` sudo umount /dev/sdb2 ```
    - Để xem UUIDS trên hệ thống cho các thiết bị khối ``` sudo blkid ```
    - Như vậy đã thấy UUID để gắn kêt có thể sử dụng ``` sudo mount UUID=130b882f-7d79-436d-a096-1e594c92bb76 /mydrive ```
    
  - /etc/fstab
    - Khi chúng ta muốn tự động gắn kết các hệ thống tập tin khi khởi động, chúng ta có thể thêm chúng vào một tập tin có tên /etc/fstab viết tắt của bảng hệ thống tập tin. Tệp này chứa danh sách cố định các hệ thống tệp được gắn kết.
      ``` cat /etc/fstab
      UUID=130b882f-7d79-436d-a096-1e594c92bb76 /               ext4    relatime,errors=remount-ro 0       1       
      ```
    - Mỗi dòng đại diện cho một hệ thống tệp, có các trường:
      - UUID - Mã định danh thiết bị
      - Điểm gắn kết - Thư mục hệ thống tệp được gắn vào
      - Loại hệ thống tập tin
      - Tùy chọn - các tùy chọn gắn kết khác, xem trang chủ để biết thêm chi tiết
      - Dump - được sử dụng bởi tiện ích kết xuất để quyết định thời điểm thực hiện sao lưu, bạn chỉ nên đặt mặc định là 0
      - Pass - Được fsck sử dụng để quyết định thứ tự hệ thống tệp nào nên được kiểm tra, nếu giá trị là 0, nó sẽ không được kiểm tra
  
  - swap
    - Hoán đổi tốt là những gì sử dụng để cấp phát bộ nhớ ảo cho hệ thống. Nếu sắp hết bộ nhớ, hệ thống sử dụng phân vùng này để "hoán đổi" các phần bộ nhớ của các tiến trình không hoạt động vào đĩa.
    - Sử dụng phân vùng để hoán đổi không gian:
    - Ví dụ muốn thiết lập phân vùng /dev/sdb2 để được sử dụng cho không gian hoán đổi
      - Trước tiên, hãy đảm bảo rằng không có bất kỳ thứ gì trên phân vùng
      - Chạy: mkswap / dev / sdb2 để khởi tạo các khu vực hoán đổi
      - Chạy: swapon / dev / sdb2, điều này sẽ cho phép thiết bị hoán đổi
      - Nếu muốn phân vùng hoán đổi vẫn tiếp tục khởi động, cần thêm mục nhập vào tệp / etc / fstab. sw là loại hệ thống tệp mà bạn sẽ sử dụng.
      - Để xóa swap: swapoff / dev / sdb2
  
  - Disk Usage
    - Lệnh df cho thấy việc sử dụng các hệ thống tệp hiện đang được gắn kết, -h cùng cấp một định dạng mà con người có thể đọc được, có thể xem thiết bị là gì, dung lượng sử dụng và khả dụng là bao nhiêu.
    - Ví dụ dung lượng sắp đầy và cần biết thư mục hay tệp nào đang chiếm dung lượng thì hãy sử dụng lệnh ``` du ```
    
  - Filesystem Repair
    - Lệnh fsck (kiểm tra hệ thống tệp) được sử dụng để kiểm tra tính nhất quán của hệ thống tệp và thậm chí có thể cố gắng sửa chữa. Thông thường khi khởi động đĩa, fsck sẽ chạy trước khi đĩa được gắn để đảm bảo mọi thứ đều ổn. Tuy nhiên, đôi khi, đĩa quá tệ nên cần phải thực hiện việc này theo cách thủ công. Tuy nhiên, hãy đảm bảo thực hiện việc này khi bạn đang ở trong đĩa cứu hộ hoặc nơi nào đó mà có thể truy cập hệ thống tệp của mình mà không cần gắn kết.
    - ```sudo fsck /dev/sda ``` 
    
  - Inodes
    - Inode là gì: Một inode (nút chỉ mục) là một mục nhập trong bảng này và có một mục cho mọi tệp. Nó mô tả mọi thứ về tệp, chẳng hạn như:
      - Loại tệp - tệp thông thường, thư mục, thiết bị ký tự, v.v.
      - Người sở hữu
      - Tập đoàn
      - Quyền truy cập
      - Dấu thời gian - mtime (thời gian sửa đổi tệp cuối cùng), ctime (thời gian thay đổi thuộc tính cuối cùng), atime (thời gian của lần truy cập cuối cùng)
      - Số lượng liên kết cứng đến tệp
      - Kích thước của tệp
      - Số khối được phân bổ cho tệp
      - Con trỏ đến các khối dữ liệu của tệp
    - Inodes được tạo khi nào: Khi một hệ thống tệp được tạo, không gian cho các inodes cũng được phân bổ. Có những thuật toán diễn ra để xác định dung lượng inode cần tùy thuộc vào dung lượng của đĩa và hơn thế nữa. Có thể đã từng gặp lỗi vì sự cố hết dung lượng đĩa. Điều tương tự cũng có thể xảy ra đối với các inodes (mặc dù ít phổ biến hơn), có thể hết inodes và do đó không thể tạo thêm tệp. Hãy nhớ việc lưu trữ dữ liệu phụ thuộc vào cả dữ liệu và cơ sở dữ liệu (inodes).
    - Thông tin inode: Inode được xác định bằng số, khi một tệp được tạo, nó sẽ được gán một số inode, số được gán theo thứ tự tuần tự. Tuy nhiên, đôi khi có thể nhận thấy khi tạo một tệp mới, nó nhận được số inode thấp hơn những người khác, điều này là do khi các inode bị xóa, chúng có thể được sử dụng lại bởi các tệp khác. Để xem số inode, chạy ``` ls -li ``` 
    - Cách để inodes định vị tệp: Inodes trỏ đến các khối dữ liệu thực tế của tệp. Trong một hệ thống tệp điển hình (không phải tất cả đều hoạt động giống nhau), mỗi inode chứa 15 con trỏ, 12 con trỏ đầu tiên trỏ trực tiếp đến các khối dữ liệu. Con trỏ thứ 13, trỏ tới một khối chứa con trỏ đến nhiều khối hơn, con trỏ thứ 14 trỏ đến một khối con trỏ lồng nhau khác và con trỏ thứ 15 lại trỏ tới một khối con trỏ khác.
    
  - symlinks
    - Các liên kết tượng trưng cho phép liên kết đến một tệp khác bằng tên tệp của nó. Một loại liên kết khác được tìm thấy trong Linux là liên kết cứng, đây thực sự là một tệp khác có liên kết đến inode.
    - Các liên kết tượng trưng được ký hiệu là ->.
    - Số inode là duy nhất cho hệ thống tệp, bạn không thể có hai số inode giống nhau trong một hệ thống tệp, có nghĩa là không thể tham chiếu một tệp trong một hệ thống tệp khác bằng số inode của nó. Tuy nhiên, nếu sử dụng các liên kết tượng trưng, chúng không sử dụng số inode mà sử dụng tên tệp, vì vậy chúng có thể được tham chiếu trên các hệ thống tệp khác nhau.  
    - Liên kết cứng: Một liên kết cứng chỉ tạo một tệp khác có liên kết đến cùng một inode.
    - Tạo liên kết biểu tượng: ``` ln -s myfile mylink ``` , Để tạo một liên kết tượng trưng, sử dụng lệnh ln với -s cho biểu tượng và bạn xác định một tệp đích và sau đó là tên liên kết. 
    - Tạo một liên kết cứng: ``` ln somefile somelink ``` 
    
## 11. Boot the System  
 - Boot Process Overview
   - Chia làm 4 giai đoạn:
     - BIOS: BIOS (là viết tắt của "Hệ thống đầu vào / đầu ra cơ bản") khởi tạo phần cứng và đảm bảo với tự kiểm tra khi bật nguồn (POST) rằng tất cả phần cứng đều hoạt động tốt. Công việc chính của BIOS là tải bộ nạp khởi động.
     - Bộ nạp khởi động: Bộ nạp khởi động tải nhân vào bộ nhớ và sau đó khởi động nhân với một tập hợp các tham số của nhân. Một trong những bộ nạp khởi động phổ biến nhất là GRUB, đây là một tiêu chuẩn phổ biến của Linux.
     - Nhân (Kernel): Khi kernel được tải, nó ngay lập tức khởi tạo các thiết bị và bộ nhớ. Công việc chính của kernel là tải tiến trình init.
     - Init: Quá trình init là quá trình đầu tiên được bắt đầu, init bắt đầu và dừng quá trình dịch vụ thiết yếu trên hệ thống. Có ba cách triển khai chính của init trong các bản phân phối Linux.
 
 - Boot Process: BIOS
   - BIOS
     - Bước đầu tiên trong quá trình khởi động Linux là BIOS thực hiện kiểm tra tính toàn vẹn của hệ thống. BIOS là phần sụn phổ biến nhất trong các máy tính tương thích với IBM PC, loại máy tính chiếm ưu thế hiện nay. Có thể đã sử dụng phần sụn BIOS để thay đổi thứ tự khởi động của đĩa cứng, kiểm tra thời gian hệ thống, địa chỉ mac của máy, v.v. Mục tiêu chính của BIOS là tìm bộ nạp khởi động hệ thống.
     - khi BIOS khởi động ổ cứng, nó sẽ tìm kiếm khối khởi động để tìm ra cách khởi động hệ thống. Tùy thuộc vào cách phân vùng đĩa của mình, nó sẽ giống như bản ghi khởi động chính (MBR) hoặc GPT. MBR nằm trong sector đầu tiên của ổ cứng, 512 byte đầu tiên. MBR chứa mã để tải một chương trình khác ở đâu đó trên đĩa, chương trình này thực sự tải lên bộ nạp khởi động. 
   - UEFI
     - Là một cách khác để khởi động hệ thống thay vì sử dụng BIOS.
     - UEFI được thiết kế để kế thừa BIOS, hầu hết phần cứng hiện có ngày nay đều được tích hợp sẵn firmware UEFI. Các máy Macintosh đã sử dụng khả năng khởi động EFI trong nhiều năm nay và Windows hầu như đã chuyển tất cả nội dung của chúng sang khởi động UEFI. Định dạng GPT được thiết kế để sử dụng với EFI. Không nhất thiết phải cần EFI nếu đang khởi động đĩa GPT. Khu vực đầu tiên của đĩa GPT được dành riêng cho một "MBR bảo vệ" để có thể khởi động máy dựa trên BIOS.
     - UEFI lưu trữ tất cả thông tin về khởi động trong tệp .efi. Tệp này được lưu trữ trên một phân vùng đặc biệt được gọi là phân vùng hệ thống EFI trên phần cứng. Bên trong phân vùng này, nó sẽ chứa bộ nạp khởi động. UEFI đi kèm với nhiều cải tiến từ phần sụn BIOS truyền thống. Tuy nhiên, vì chúng ta đang sử dụng Linux nên phần lớn chúng ta đang sử dụng BIOS.
   
 - Boot Process: Bootloader
   - Các trách nhiệm chính của bootloader:
     - Khởi động vào một hệ điều hành, nó cũng có thể được sử dụng để khởi động vào các hệ điều hành không phải Linux
     - Chọn một nhân để sử dụng
     - Chỉ định các tham số hạt nhân
   - Bộ nạp khởi động phổ biến nhất cho Linux là GRUB. 
   - Có nhiều bộ nạp khởi động khác mà có thể sử dụng như LILO, efilinux, coreboot, SYSLINUX và hơn thế nữa.
   - Các tham số có thể được tìm thấy bằng cách vào menu GRUB khi khởi động bằng phím 'e'. Nếu không có GRUB, xem xét các thông số khởi động sẽ thấy:
     - initrd - Chỉ định vị trí của đĩa RAM ban đầu (chúng ta sẽ nói rõ hơn về vấn đề này trong bài học tiếp theo).
     - BOOT_IMAGE - Đây là nơi chứa hình ảnh hạt nhân
     - root - Vị trí của hệ thống tập tin gốc, hạt nhân tìm kiếm bên trong vị trí này để tìm init. Nó thường được biểu thị bằng UUID hoặc tên thiết bị như / dev / sda1.
     - ro - Tham số này khá chuẩn, nó gắn hệ thống tập tin ở chế độ chỉ đọc.
     - quite - Điều này được thêm vào để bạn không nhìn thấy các thông báo hiển thị đang diễn ra ở chế độ nền trong khi khởi động.
     - splash - Điều này cho phép hiển thị màn hình giật gân.
     
 - Boot Process: Kernel
   - Initrd vs Initramfs
     - Kernel quản lý phần cứng hệ thống, tuy nhiên không phải tất cả các trình điều khiển đều có sẵn cho kernel trong quá trình khởi động. Vì vậy, phụ thuộc vào một hệ thống tệp gốc tạm thời chỉ chứa các mô-đun thiết yếu mà hạt nhân cần để truy cập vào phần còn lại của phần cứng. 
     - Trong các phiên bản cũ hơn của Linux, công việc này được giao cho initrd (đĩa ram ban đầu). Kernel sẽ gắn initrd, lấy các trình điều khiển khởi động cần thiết, sau đó khi tải xong mọi thứ cần thiết, nó sẽ thay thế initrd bằng hệ thống tệp gốc thực sự. Ngày nay, chúng ta có một thứ gọi là initramfs, đây là một hệ thống tệp gốc tạm thời được tích hợp sẵn trong chính hạt nhân để tải tất cả các trình điều khiển cần thiết cho hệ thống tệp gốc thực, vì vậy không cần phải định vị tệp initrd nữa.
   - Gắn hệ thống tệp gốc
     - Bây giờ hạt nhân có tất cả các mô-đun nó cần để tạo thiết bị gốc và gắn kết phân vùng gốc. 
     - Tuy nhiên, trước khi tiếp tục, phân vùng gốc thực sự được gắn ở chế độ chỉ đọc để fsck có thể chạy an toàn và kiểm tra tính toàn vẹn của hệ thống. Sau đó, nó kết nối lại hệ thống tệp gốc ở chế độ đọc-ghi. Sau đó, hạt nhân định vị chương trình init và thực thi nó.
 
 - Boot Process: Init
   - System V init (sysv)
     - Đây là hệ thống init truyền thống. 
     - Nó tuần tự bắt đầu và dừng các quy trình, dựa trên các tập lệnh khởi động. 
     - Trạng thái của máy được biểu thị bằng các cấp chạy, mỗi cấp chạy khởi động hoặc dừng một máy theo một cách khác nhau. 
   - Upstart
     - Đây là init sẽ tìm thấy trên các bản cài đặt Ubuntu cũ hơn. 
     - Upstart sử dụng ý tưởng về các công việc và sự kiện và hoạt động bằng cách bắt đầu các công việc thực hiện các hành động nhất định để phản ứng lại các sự kiện.  
   - Systemd
     - Đây là tiêu chuẩn mới cho init, nó hướng tới mục tiêu.
     - Về cơ bản, có một mục tiêu mà muốn đạt được và systemd cố gắng đáp ứng các yếu tố phụ thuộc của mục tiêu để hoàn thành mục tiêu.
 
## 12. Kernel 
 - Overview of the Kernel
   - Hạt nhân là cốt lõi của hệ điều hành. 
   - Hệ điều hành Linux có thể được tổ chức thành ba cấp độ trừu tượng khác nhau:
     - Cấp cơ bản nhất: phần cứng, bao gồm CPU, bộ nhớ, đĩa cứng, cổng mạng, v.v. Lớp vật lý thực sự tính toán những gì máy đang làm.
     - Cấp độ tiếp theo là hạt nhân, xử lý quá trình và quản lý bộ nhớ, giao tiếp thiết bị, lệnh gọi hệ thống, thiết lập hệ thống tệp của chúng ta, v.v. Công việc của hạt nhân là nói chuyện với phần cứng để đảm bảo nó thực hiện những gì muốn các quá trình của làm. 
     - Không gian người dùng bao gồm trình bao, chương trình, đồ họa, v.v.
     
 - Privilege Levels
   - Trong chế độ kernel, kernel có toàn quyền truy cập vào phần cứng, nó kiểm soát mọi thứ. Trong chế độ không gian người dùng, có một lượng rất nhỏ bộ nhớ an toàn và CPU mà được phép truy cập.
   - Các chế độ khác nhau này được gọi là các mức đặc quyền (được đặt tên phù hợp cho các mức đặc quyền mà nhận được) và thường được mô tả như các vòng bảo vệ.
   
 - System Calls
   - Các cuộc gọi hệ thống (syscall) cung cấp cho các quy trình không gian người dùng một cách để yêu cầu hạt nhân làm một việc gì đó. 
   - Kernel cung cấp một số dịch vụ nhất định thông qua API gọi hệ thống. Các dịch vụ này cho phép đọc hoặc ghi vào một tệp, sửa đổi mức sử dụng bộ nhớ, sửa đổi mạng, v.v. 
   - Số lượng dịch vụ là cố định, vì vậy không thể thêm lệnh gọi hệ thống hoàn toàn, hệ thống đã có một bảng hệ thống cuộc gọi tồn tại và mỗi cuộc gọi hệ thống có một ID duy nhất.
   - Có thể xem các lệnh gọi hệ thống mà tiến trình thực hiện bằng lệnh strace: ``` strace ls ```
   
 - Kernel Installation
   - Để xem có phiên bản kernel nào trên hệ thống sử dụng lệnh ``` uname -r ```. lệnh uname in thông tin hệ thống, -r in ra tất cả các phiên bản phát hành.
   - Có thể cài đặt nhân Linux theo nhiều cách khác nhau, có thể tải xuống gói nguồn và biên dịch từ nguồn hoặc có thể cài đặt nó bằng các công cụ quản lý gói: ``` sudo apt install linux-generic-lts-living ```
   - Nâng cấp ``` sudo apt dist-upgrade ```
   
 - Kernel Location
   - Khi cài đặt kernel mới nó sẽ thêm vài tệp vào hệ thống, những tệp này sẽ thường được thêm vào thư mục /boot, sẽ thấy nhiều tệp cho các phiên bản kernel khác nhau:
     - vmlinuz - đây là hạt nhân linux thực tế
     - initrd - như chúng ta đã thảo luận trước đây, initrd được sử dụng như một hệ thống tệp tạm thời, được sử dụng trước khi tải hạt nhân
     - System.map - bảng tra cứu tượng trưng
     - config - cài đặt cấu hình hạt nhân, nếu bạn đang biên dịch hạt nhân của riêng mình, bạn có thể đặt mô-đun nào có thể được tải
   
 - Kernel Modules
   - Bản thân hạt nhân là một phần mềm nguyên khối, khi chúng ta muốn thêm hỗ trợ cho một loại bàn phím mới, chúng ta không viết mã này trực tiếp vào mã hạt nhân. Mô-đun nhân là các đoạn mã có thể được tải và dỡ xuống nhân theo yêu cầu. Chúng cho phép chúng ta mở rộng chức năng của hạt nhân mà không thực sự thêm vào mã nhân chính. Chúng tôi cũng có thể thêm các mô-đun và không phải khởi động lại hệ thống (trong hầu hết các trường hợp). 
   - Xem danh sách các module đã tải ``` lsmod ```
   - Tải module ``` sudo modprobe bluetooth ```
   - Xóa ``` sudo modprobe -r bluetooth ```
   - Tải khi khởi động: có thể tải các mô-đun trong khi khởi động hệ thống, thay vì tải tạm thời bằng modprobe (sẽ được tải khi bạn khởi động lại). Chỉ cần sửa đổi thư mục /etc/modprobe.d và thêm tệp cấu hình vào đó như sau: 
      ``` /etc/modprobe.d/peanutbutter.conf 
          options peanut_butter type=almond
      ```
   - Không tải khi khởi động: 
      ``` /etc/modprobe.d/peanutbutter.conf 
          blacklist peanut_butter
      ``` 
      
## 13. Init
 - System V Overview
   - Mục đích chính của init là khởi động và dừng các tiến trình thiết yếu trên hệ thống. Có ba cách triển khai chính của init trong Linux, System V, Upstart và systemd.
   - Nếu có tệp /etc/inittab thì rất có thể đang chạy Sys V.
   - Sys V bắt đầu và dừng các quy trình một cách tuần tự.
   - Ưu điểm của việc sử dụng triển khai init này là nó tương đối dễ dàng để giải quyết các phụ thuộc.
   - Khi sử dụng Sys V, trạng thái của máy được xác định bởi các cấp chạy được đặt từ 0 đến 6. Các chế độ khác nhau này sẽ khác nhau tùy thuộc vào phân phối, nhưng hầu hết thời gian sẽ giống như sau:
     - 0: tắt máy
     - 1: chế độ một người dùng
     - 2: chế độ đa người dùng không kết nối mạng
     - 3: chế độ đa người dùng với mạng
     - 4: không sử dụng
     - 5: chế độ đa người dùng với mạng và GUI
     - 6: khởi động lại
   - Khi hệ thống của khởi động, nó sẽ xem đang ở cấp độ chạy nào và thực thi các tập lệnh nằm bên trong cấu hình cấp độ chạy đó. 
   - Các tập lệnh nằm trong /etc/rc.d/rc[runlevel number] .d / hoặc /etc/init.d . Các tập lệnh bắt đầu bằng S (start) hoặc K (kill) sẽ chạy tương ứng khi khởi động và tắt máy. Các số bên cạnh các ký tự này là thứ tự mà chúng chạy trong đó. 
     
 - System V Service
  - Liệt kê các dịch vụ ``` service --status-all ```
  - Bắt đầu dịch vụ ``` sudo service networking start ```
  - Dừng dịch vụ ``` sudo service networking stop ``` 
  - Khởi động lại 1 dịch vụ ``` sudo service networking restart ``` 
 
 - Upstart Overview
   - Upstart được phát triển bởi Canonical, vì vậy nó đã được triển khai init trên Ubuntu trong một thời gian, tuy nhiên trên các bản cài đặt Ubuntu hiện đại, systemd hiện đã được sử dụng. 
   - Upstart được tạo ra để cải thiện các vấn đề với Sys V, chẳng hạn như quy trình khởi động nghiêm ngặt, chặn các tác vụ, v.v. Mô hình hướng sự kiện và công việc của Upstart cho phép nó phản hồi các sự kiện khi chúng xảy ra.
   - Để tìm hiểu xem có đang sử dụng Upstart hay không, nếu có thư mục /usr/share/upstart.
   - Công việc là các hành động mà Upstart thực hiện và các sự kiện là thông báo nhận được từ các quy trình khác để kích hoạt công việc.
   - Xem công việc và cấu hình ``` ls /etc/init ```
   - Cách thức hoạt động của Upstart là:
     - Đầu tiên, nó tải lên các cấu hình công việc từ /etc/init
     - Khi một sự kiện khởi động xảy ra, nó sẽ chạy các công việc được kích hoạt bởi sự kiện đó.
     - Những công việc này sẽ tạo ra những sự kiện mới và sau đó những sự kiện đó sẽ tạo ra nhiều công việc hơn
     - Upstart tiếp tục thực hiện việc này cho đến khi hoàn thành tất cả các công việc cần thiết     
 
 - Upstart Jobs
   - Upstart có thể kích hoạt rất nhiều sự kiện và công việc để chạy, rất tiếc là không có cách nào dễ dàng để xem nơi bắt nguồn một sự kiện hoặc công việc, vì vậy sẽ phải xem xét các cấu hình công việc trong /etc/init. 
   - Có rất nhiều lệnh hữu ích có thể sử dụng trong hệ thống Upstart:
     - Xem công việc ``` initctl list ``` 
     - Xem công việc cụ thể ``` initctl status networking ```
     - Bắt đầu công việc theo cách thủ công ``` sudo initctl start networking ```
     - Dừng công việc theo cách thủ công ``` sudo initctl stop networking ```
     - Bắt đầu lại công việc theo cách thủ công ``` sudo initctl restart networking ```
     - Phát ra một sự kiện theo cách thủ công ``` sudo initctl emit some_event ```   
 - Systemd Overview
   - Systemd đang dần trở thành tiêu chuẩn mới nổi cho init. Nếu có thư mục /usr/lib/systemd, rất có thể đang sử dụng systemd.
   - Systemd sử dụng các mục tiêu để thiết lập và chạy hệ thống
   - Systemd cực kỳ linh hoạt và mạnh mẽ, nó không tuân theo một trình tự nghiêm ngặt để bắt đầu các quy trình. Đây là những gì xảy ra trong quá trình khởi động systemd điển hình:
     - Đầu tiên, systemd tải các tệp cấu hình của nó, thường nằm trong /etc/systemd/system hoặc /usr/lib/systemd/system
     - Sau đó, nó xác định mục tiêu khởi động, thường là mặc định.
     - Systemd tìm ra các phụ thuộc của mục tiêu khởi động và kích hoạt chúng
   - Systemd khởi động vào các mục tiêu khác nhau:
     - poweroff.target - hệ thống tắt máy
     - Rescue.target - chế độ một người dùng
     - multi-user.target - đa người dùng với mạng
     - graphical.target - đa người dùng với mạng và GUI
     - reboot.target - khởi động lại
   - Đối tượng chính mà systemd làm việc được gọi là đơn vị. Systemd không chỉ dừng và khởi động các dịch vụ, nó có thể gắn kết các hệ thống tập tin, giám sát các ổ cắm mạng, v.v. và vì sự mạnh mẽ đó, nó có các loại đơn vị khác nhau mà nó hoạt động. Các đơn vị phổ biến nhất là: 
     - Đơn vị dịch vụ - đây là những dịch vụ chúng tôi đã bắt đầu và dừng lại, các tệp đơn vị này kết thúc bằng .service
     - Gắn kết các đơn vị - Các hệ thống tệp gắn kết này, các tệp đơn vị này kết thúc bằng .mount
     - Các đơn vị mục tiêu - Các đơn vị này nhóm lại với nhau các đơn vị khác, các tệp kết thúc bằng .target       
 
 - Systemd Goals
   - Tệp dịch vụ cơ bản: foodar.service:
     ```
     [Unit] // cung cấp cho tệp đơn vị và kiểm soát thứ tự thời điểm kích hoạt thiết bị
     Description=My Foobar
     Before=bar.target
     [Service] // Có thể bắt đầu hoặc dừng lại hoặc tải lại dịch vụ
     ExecStart=/usr/bin/foobar
     [Install] // được sử dụng để phụ thuộc
     WantedBy=multi-user.target
     -   
     - Power States
     ```
   
   - Một số lệnh sử dụng với các đơn vị systemd  
     - Liệt kê các đơn vị ``` systemctl list-units ```
     - Xem trạng thái của đơn vị ``` systemctl status networking.service ``` 
     - Bắt đầu một dịch vụ ``` sudo systemctl start networking.service ``` 
     - Dừng dịch vụ ``` sudo systemctl stop networking.service ```
     - Khởi động lại một dịch vụ ``` sudo systemctl restart networking.service ```
     - Bật một đơn vị ``` sudo systemctl enable networking.service ```  
     - Vô hiệu hóa một đơn vị ``` sudo systemctl disable networking.service ```
 
 - Power States
   - Tắt hệ thống ``` sudo shutdown -h now ``` 
   - Tắt hệ thống nhưng thêm thời gian chỉ định tính bằng phút ``` sudo shutdown -h +2 ``` 
   - Khởi động lại bằng lệnh tắt máy ``` sudo shutdown -r now ``` 
   - Khởi động lại ``` sudo reboot ``` 
 
## 14. Process Utilization
 - Tracking process: top
   - top
      ```
      top - 18:06:26 up 6 days,  4:07,  2 users,  load average: 0.92, 0.62, 0.59
      Tasks: 389 total,   1 running, 387 sleeping,   0 stopped,   1 zombie
      %Cpu(s):  1.8 us,  0.4 sy,  0.0 ni, 97.6 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st
      KiB Mem:  32870888 total, 27467976 used,  5402912 free,   518808 buffers
      KiB Swap: 33480700 total,    39892 used, 33440808 free. 19454152 cached Mem
      PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND         6675 patty    20   0 1731472 520960  30876 S   8.3  1.6 160:24.79 chrome           6926 patty    20   0  935888 163456  25576 S   4.3  0.5   5:28.13 chrome 
      ```
   - Dòng 1: Đây là thông tin tương tự sẽ thấy nếu chạy lệnh thời gian hoạt động, các trường từ trái sang phải:
     - Thời điểm hiện tại
     - Hệ thống đã hoạt động trong bao lâu
     - Có bao nhiêu người dùng hiện đang đăng nhập
     - Mức trung bình tải của hệ thống 
   - Dòng 2: Các tác vụ đang chạy, ngủ, dừng và chuyển động
   - Dòng 3: Thông tin CPU
     - us: thời gian sử dụng CPU của người dùng - Tỷ lệ phần trăm thời gian CPU dành cho việc chạy các quy trình của người dùng không liên quan.
     - sy: thời gian CPU của hệ thống - Phần trăm thời gian CPU dành để chạy hạt nhân và các quá trình hạt nhân
     - ni: thời gian CPU tốt - Tỷ lệ phần trăm thời gian CPU dành để chạy các quy trình bắt buộc
     - id: Thời gian không hoạt động của CPU - Phần trăm thời gian CPU được sử dụng ở chế độ nhàn rỗi
     - wa: I / O wait - Phần trăm thời gian CPU dành để chờ I / O. Nếu giá trị này thấp, vấn đề có thể không phải là ổ đĩa hoặc I / O mạng
     - hi: phần cứng ngắt - Tỷ lệ phần trăm thời gian CPU dành để phục vụ các phần cứng bị gián đoạn
     - si: phần mềm ngắt - Tỷ lệ phần trăm thời gian CPU dành để phục vụ phần mềm bị gián đoạn
     - st: ăn cắp thời gian - Nếu bạn đang chạy máy ảo, đây là phần trăm thời gian CPU đã bị đánh cắp từ bạn cho các tác vụ khác
   - Dòng 4 và 5: Sử dụng bộ nhớ và sử dụng hoán đổi
   - Danh sách quy trình hiện đang được sử dụng
     - PID: Id của quy trình
     - USER: người dùng là chủ sở hữu của quá trình
     - PR: Mức độ ưu tiên của quy trình
     - NI: Giá trị tốt đẹp
     - VIRT: Bộ nhớ ảo được sử dụng bởi quá trình 
     - RES: Bộ nhớ vật lý được sử dụng từ quá trình
     - SHR: Bộ nhớ được chia sẻ về quy trình
     - S: Cho biết trạng thái của quá trình: S = ngủ, R = đang chạy, Z = xác sống, D = không gián đoạn, T = dừng
     - % CPU - đây là phần trăm CPU được sử dụng bởi quá trình này
     - % MEM - phần trăm RAM được sử dụng bởi quá trình này
     - TIME + - tổng thời gian hoạt động của quá trình này
     - COMMAND - tên của quá trình
   - Có thể chỉ định một ID quy trình nếu chỉ muốn theo dõi các quy trình nhất định ``` top -p 1 ```        

 - Isof and fuser
   - Isof: Tệp không chỉ là tệp văn bản, hình ảnh, v.v., chúng là tất cả mọi thứ trên hệ thống, đĩa, đường ống, ổ cắm mạng, thiết bị, v.v. Để xem những gì được sử dụng bởi một quy trình, có thể sử dụng lệnh lsof (viết tắt của "liệt kê các tệp đang mở") điều này sẽ hiển thị cho bạn danh sách tất cả các tệp đang mở và quy trình liên quan của chúng.
   - fuser: Một cách khác để theo dõi một quá trình là lệnh fuser (viết tắt của "file user"), lệnh này sẽ hiển thị thông tin về quá trình đang sử dụng tệp hoặc người dùng tệp.    
 
 - Process Threads
   - Các luồng rất giống với các quy trình, ở chỗ chúng được sử dụng để thực thi cùng một chương trình, chúng thường được gọi là các quy trình nhẹ. 
   - Nếu một quy trình có một luồng thì nó là một luồng và nếu một quy trình có nhiều hơn một luồng thì nó là đa luồng. Tuy nhiên, tất cả các quy trình đều có ít nhất một luồng. 
   - Các quy trình hoạt động với các tài nguyên hệ thống cô lập của riêng chúng, tuy nhiên các luồng có thể chia sẻ các tài nguyên này với nhau một cách dễ dàng, giúp chúng giao tiếp với nhau dễ dàng hơn và đôi khi sẽ hiệu quả hơn nếu có một ứng dụng đa luồng hơn là một ứng dụng đa quy trình.
   - Để xem các chuỗi quy trình sử dụng lệnh ``` ps m ``` , các quy trình được ký hiệu với mỗi PID và bên dưới là các luồng của chúng (kí hiệu a-).
 
 - CPU Monitoring
   - Lệnh ``` uptime ``` để xem mức trung bình tải
   - Mức trung bình tải là cách tốt để xem tải CPU trên hệ thống. Những con số này thể hiện mức tải trung bình của CPU trong các khoảng thời gian 1, 5 và 15 phút. 
 
 - I/O Monitoring
   - Lệnh ``` iostat ``` dùng để theo dõi việc sử dụng CPU cũng như theo dõi việc sử dụng đĩa.
     ```
     iostat
     Linux 3.13.0-39-lowlatency (icebox)     01/28/2016      _i686_  (1 CPU)
     avg-cpu:  %user   %nice %system %iowait  %steal   %idle
     0.13    0.03    0.50    0.01    0.00   99.33
     Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
     sda               0.17         3.49         1.92     385106     212417
     ```
   - Phần đầu là thông tin CPU:
     - %user: Hiển thị phần trăm sử dụng CPU đã xảy ra khi thực thi ở cấp người dùng (ứng dụng)
     - %nice: Hiển thị phần trăm sử dụng CPU đã xảy ra trong khi thực thi ở cấp độ người dùng với mức độ ưu tiên tốt. Việc sử dụng CPU của người dùng với mức độ ưu tiên tốt 
     - %system: Hiển thị phần trăm sử dụng CPU đã xảy ra trong khi thực thi ở cấp hệ thống (nhân).
     - %iowait: Hiển thị phần trăm thời gian CPU hoặc các CPU không hoạt động trong đó hệ thống có yêu cầu I / O đĩa chưa xử lý.  
     - %steal: Hiển thị phần trăm thời gian chờ đợi không tự nguyện của CPU ảo hoặc các CPU trong khi trình siêu giám sát đang bảo dưỡng một bộ xử lý ảo khác.
     - %idle: Hiển thị phần trăm thời gian CPU hoặc các CPU không hoạt động và hệ thống không có yêu cầu I / O đĩa chưa xử lý.
   - Phần 2 là sử dụng đĩa:
     - tps - Cho biết số lần truyền mỗi giây đã được cấp cho thiết bị. Chuyển là một yêu cầu I / O tới thiết bị. Nhiều yêu cầu logic có thể được kết hợp thành một yêu cầu I / O duy nhất tới thiết bị. Một chuyển nhượng có kích thước không xác định.
     - kB_read / s - Cho biết lượng dữ liệu được đọc từ thiết bị được biểu thị bằng kilobyte mỗi giây.
     - kB_wrtn / s - Cho biết lượng dữ liệu được ghi vào thiết bị được biểu thị bằng kilobyte mỗi giây.
     - kB_read - Tổng số kilobyte được đọc.
     - kB_wrtn - Tổng số kilobyte được viết.   
  
 - Memory Monitoring
   - Lệnh ``` vmstat ``` dùng để theo dõi việc sử dụng bộ nhớ
     ```
     vmstat
     procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
     r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
     1  0      0 396528  38816 384036    0    0     4     2   38   79  0  0 99  0  0
     ```
   - Có các trường:
     - procs: 
       - r: số quá trình cho thời gian chạy
       - b: số lượng quá trình trong chế độ ngủ liên tục
     - memory:
       - swpd: Dung lượng bộ nhớ ảo được sử dụng
       - free: Dung lượng bộ nhớ trống
       - buff: Lượng bộ nhớ được sử dụng làm bộ đệm
       - cache: Lượng bộ nhớ được sử dụng làm bộ nhớ đệm
     - swap:
       - si: Dung lượng bộ nhớ được hoán đổi trong đĩa
       - so: Dung lượng bộ nhớ được hoán đổi ra đĩa
     - io:
       - bi: Số lượng khối nhận được từ một thiết bị khối
       - bo: Số lượng khối được gửi đến một thiết bị khối
     - system:
       - in: Số lần ngắt mỗi giây
       - cs: Số lần chuyển đổi ngữ cảnh mỗi giây
     - cpu:
       - us: Thời gian dành cho người dùng
       - si: Thời gian dành cho thời gian hạt nhân
       - id: Thời gian nhàn rỗi
       - wa: Thời gian chờ IO
      
 - Continuous Monitoring
   - Sử dụng ``` sar ``` để giám sát liên tục, thu thập, báo cáo và lưu thông tin hoạt động hệ thống.
   - Cài đặt sar: Sar là một công cụ được sử dụng để phân tích lịch sử trên hệ thống, cài nó bằng cách cài đặt gói sysstat sudo apt install sysstat.
   - Thiết lập thu thập dữ liệu: Thông thường khi cài đặt sysstat, hệ thống sẽ tự động bắt đầu thu thập dữ liệu, nếu không, có thể kích hoạt nó bằng cách sửa đổi trường ENABLED trong /etc/default/sysstat.
   - Sử dụng sar ``` sudo sar -q ```
   - Liệt kê các chi tiết từ đầu ngày ``` sudo sar -r ```
   - Liệt kê các chi tiết về việc sử dụng bộ nhớ từ đầu ngày ``` sudo sar -P ```
   - Liệt kê các chi tiết về việc sử dụng CPU ``` sar -q /var/log/sysstat/sa02 ```
   - Để xem chế độ xem của một ngày khác, có thể truy cập /var/log/sysstat/saXX trong đó XX là ngày bạn muốn xem.
 
 - Cron Jobs
   - ``` Cron ``` dùng để lập lịch các tác vụ.
   - Ví dụ: Có một tập lệnh nằm trong /home/pete/scripts/change_wallpaper. Sử dụng tập lệnh này mỗi sáng để thay đổi hình ảnh sử dụng cho hình nền, nhưng mỗi sáng phải thực thi tập lệnh này theo cách thủ công. Thay vào đó, những gì có thể làm là tạo một công việc cron thực thi tập lệnh thông qua cron. Có thể chỉ định thời gian muốn lệnh cron này chạy và thực thi tập lệnh.
     ```
     30 08 * * * /home/pete/scripts/change_wallpaper
     ```
   - Các trường từ trái sang phải
     - Phút
     - Giờ
     - Ngày trong tháng
     - Tháng
     - Ngày trong tuần
     - Dấu * có nghĩa là khớp với mọi giá trị, như trong ví dụ trên là hằng ngày vào 8h30 sáng.
   - Tạo cronjob chỉ cần chỉnh sửa tệp crontab ``` crontab -e ```
   
## 15. Logging
 - System Logging
   - Các dịch vụ, hạt nhân, daemon, v.v. trên hệ thống đang liên tục làm điều gì đó, dữ liệu này thực sự được gửi để lưu trên hệ thống dưới dạng nhật ký.
   - Dữ liệu này thường được giữ trong thư mục /var.
   - Syslog thực sự chứa nhiều thành phần, một trong những thành phần quan trọng là một daemon đang chạy có tên là syslogd, đợi thông báo sự kiện xảy ra và lọc những thành phần mà nó muốn biết, và tùy thuộc vào những gì nó phải làm với tin nhắn đó, nó sẽ gửi nó đến một tệp, bảng điều khiển của bạn hoặc không làm gì với nó.
   - Ví dụ về dòng từ nhật kí hệ thống:
     ```
     less /var/log/syslog
     Jan 27 07:41:32 icebox anacron[4650]: Job `cron.weekly' started
     ```
   - Có thể thấy rằng vào ngày 27 tháng 1 07:41:32 dịch vụ cron của chúng tôi đã chạy công việc cron.weekly.    
 
 - syslog
   - Dịch vụ nhật ký hệ thống quản lý và gửi nhật ký đến bộ ghi nhật ký hệ thống. 
   - Rsyslog là một phiên bản nâng cao của nhật ký hệ thống, hầu hết các bản phân phối Linux sẽ sử dụng phiên bản mới này. 
   - Đầu ra của tất cả nhật ký mà dịch vụ nhật ký hệ thống thu thập có thể được tìm thấy tại /var/log/syslog
   - Để tìm hiểu những tệp nào được trình ghi nhật ký hệ thống duy trì, hãy xem các tệp cấu hình trong /etc/rsyslog.d
   - Các quy tắc này đối với tệp nhật ký được biểu thị bằng bộ chọn ở cột bên trái và hành động trên cột bên phải. 
   - Lệnh ghi nhật kí ``` logger -s Hello ```   
 
 - General Logging
   - Có hai tệp nhật ký chung mà có thể xem để biết hệ thống đang làm gì:
     - /var/log/messages: Nhật ký này chứa tất cả các thông báo không quan trọng và không gỡ lỗi, bao gồm các thông báo được ghi trong quá trình khởi động (dmesg), auth, cron, daemon, v.v. Rất hữu ích để xem máy đang hoạt động như thế nào.
     - /var/log/syslog: Điều này ghi lại mọi thứ ngoại trừ tin nhắn xác thực, nó cực kỳ hữu ích để gỡ lỗi.     
 
 - Kernel Logging
   - /var/log/dmesg:
     - Hiển thị thông tin về trình điều khiển phần cứng, thông tin hạt nhân và trạng thái trong quá trình khởi động và hơn thế nữa. Tệp nhật ký này có thể được tìm thấy tại /var/log/dmesg và được đặt lại sau mỗi lần khởi động, có thể không thực sự thấy bất kỳ công dụng nào trong đó bây giờ, nhưng nếu ừng gặp sự cố với một thứ gì đó trong quá trình khởi động hoặc sự cố phần cứng, thì dmesg là nơi tốt nhất để xem xét. Có thể xem nhật kí này bằng lệnh ``` dmesg ``` .
   - /var/log/kern.log:
     - Một bản ghi khác mà có thể sử dụng để xem thông tin kernel là tệp /var/log/kern.log, tệp này ghi lại thông tin kernel và các sự kiện trên hệ thống, nó cũng ghi đầu ra dmesg.
 
 - Authentication Logging
   - /var/log/auth.log: Điều này chứa nhật ký ủy quyền hệ thống, chẳng hạn như đăng nhập của người dùng và phương pháp xác thực được sử dụng.
   - Đoạn mã mẫu ``` Jan 31 10:37:50 icebox pkexec: pam_unix(polkit-1:session): session opened for user root by (uid=1000) ```
 
 - Managing Log Files
   - Các tệp nhật ký tạo ra nhiều dữ liệu và chúng lưu trữ dữ liệu này trên đĩa cứng.
   - Tiện ích logrotate thực hiện quản lý nhật ký. Nó có một tệp cấu hình cho phép chỉ định số lượng và những nhật ký nào cần giữ lại, cách nén nhật ký để tiết kiệm dung lượng và hơn thế nữa. Công cụ logrotate thường hết cron mỗi ngày một lần có thể tìm thấy các tệp cấu hình trong /etc/logrotate.d.
   - Có những công cụ logrotating khác có thể sử dụng để quản lý nhật ký, nhưng logrotate là công cụ phổ biến nhất.
   



     
      

   
              

      
  

  
          

   

   

      




    
  
 
    
  



     
   

           


 






    
   
  


     



                 
 

  



  

   
     

 

        
 
 
