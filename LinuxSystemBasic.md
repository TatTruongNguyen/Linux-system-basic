# Linux-system-basic

Linux System Basic
# Mục lục
## 1. Getting Started 
   - History
   - Choosing a Linux Distribution
   - Debian
   - Red Hat Enterprise Linux
   - Ubuntu
   - Fedora
   - Linux Mint
   - Gentoo
   - Arch Linux
   - openSUSE

## 1. Getting Started
 - History
    - Năm 1969, Ken Thompson và Dennis Ritchie của phòng thí nghiệm Bell phát triển hệ điều hành Unix. Sau đó được viết lại bằng C, và cuối cùng trở thành một hệ điều hành được sử dụng rộng rãi.
    - Khoảng 1 thập kỷ sau, Richard Stallman bắt đầu làm việc với dự án GNU, hạt nhân GNU được gọi là Hurd.
    - Kernel là phần quan trọng nhất trong hệ điều hành. Nó cho phép phần cứng giao tiếp với phần mềm. Hạt nhân kiểm soát mọi thứ xảy ra trên hệ thống.
    - Năm 1991, Linus Torvalds phát triển ra thứ mà sau này được biết đến là nhân Linux. 
 
 - Choosing a Linux Distribution
   -  Hệ thống Linux được chia làm ba phần chính:
     - Phần cứng - Bao gồm tất cả phần cứng mà hệ thống chạy trên đó
     - Kernel Linux - Là cốt lõi của hệ điều hành. Nó quản lý phần cứng và cho biết cách tương tác với hệ thống
     - Không gian người dùng - Nơi những người dùng sẽ tương tác với hệ thống một cách trực tiếp
   - Có nhiều tuỳ chọn về các bản phân phối Linux cho người dùng lựa chọn.
 
 - Debian   
   - Là hệ điều hành bao gồm hoàn toàn phần mềm mã nguồn mở và miễn phí, được biết đến rộng rãi và được phát triển trong hơn 20 năm. Có thể sử dụng 3 nhánh: Ổn định, Kiểm tra và Không ổn định. 
   - Quản lý gói, sử dụng các công cụ quản lý gói Debian. Mỗi bản phân phối sẽ được cài đặt và quản lý các gói khác nhau và chúng sử dụng các công cụ quản lý gói khác nhau.
   - Khả năng cấu hình, tuy có thể không nhận được các bản cập nhật mới nhất nhưng sẽ cực kì ổn định.
   - Sử dụng, là một hệ điều hành tổng thể tuyệt vời cho mọi nền tảng.
   
 - Red Hat Enterprise Linux
   - Tổng quan, thường được gọi tắt là RHEL được phát triển bởi Red Hat. Có các quy tắc nghiêm ngặt để hạn chế việc phân phối lại miễn phí mặc dù vẫn cung cấp mã nguồn miễn phí.
   - Quản lý gói, RHEL sử dụng trình quản lý gói khác với Debian, RHEL sử dụng trình quản lý gói RPM.
   - Khả năng cấu hình, Hệ điều hành dựa trên RHEL khác một chút so với hệ điều hành dựa trên Debian, đáng chú ý nhất là trong quản lý gói.
   - Công dụng, Chủ yếu sẽ được sử dụng trong doanh nghiệp, nếu cần một hệ điều hành máy chủ vững chắc thì đây sẽ là một sự lựa chọn tốt.
 
 - Ubuntu
   - Tổng quan, là bản phân phối Linux phổ biến nhất cho máy cá nhân, cũng phát hành Unity cho trình quản lý môi trường máy tính.
   - Quản lý gói, là hệ điều hành dựa trên Debian được phát triển bởi Canonical. Vì vậy nó sử dụng một hệ thống quản lý Debian cốt lõi.
   - Khả năng cấu hình, là sự lựa chọn tuyết vời cho người mới làm quen với Linux. Mang lại khả năng sử dụng dễ dàng và trải nghiệm tuyệt vời.
   - Sử dụng tuyệt vời cho mọi nền tảng.
 - Fedora
   - Được Red Hat hỗ trợ, mang tính cộng đồng bao gồm phần mềm nguồn mở và miễn phí. Fedora như một hệ điều hành RHEL ngược dòng vì là phân nhánh của RHEL.
   - Quản lý gói, sử dụng trình quản lý gói Red Hat.
   - Khả năng cấu hình, nếu như người dùng muốn sử dụng hệ điều hành dựa trên Red Hat thì đây sẽ là phiên bản thân thiện với người dùng.
   - Sử dụng, là hệ điều hành tốt nếu người dùng muốn có hệ điều hành dựa trên Red Hat.
 - Linux Mint
   - Linux Mint dựa trên Ubuntu, sử dụng kho phần mềm của Ubuntu, sẽ là bản phân phối nhẹ hơn Ubuntu.
   - Sử dụng trình quản lý gói Debian.
   - Giao diện người dùng tuyệt vời, tốt cho người mới bắt đầu và ít phức tạp hơn Ubuntu.
   - Sử dụng tốt cho máy tính PC và laptop.
 - Gentoo
   - Mang lại sự linh hoạt, được tạo ra cho những người dùng cao cấp.
   - Sử dụng trình quản lý gói của riêng mình, Portage. Việc quản lý gói Portage rất dễ bảo trì, linh hoạt, đóng vai trò quan trọng trong toàn bộ hệ điều hành.
   - Muốn đi theo con đường khó khăn hơn khi mới bắt đầu Linux thì nên chọn Gentoo.
   - Sử dụgn tuyệt vời cho PC và laptop.
 - Arch Linux
   - Là bản phân phối nhẹ và linh hoạt được thúc đẩy 100% từ cộng đồng. Arch sử dụng mô hình phát hành luân phiên như Debian.
   - Sử dụng trình quản lý gói của riêng mình, Pacman, để cài đăt, cập nhật và quản lý các gói.
   - Là một sự lựa chọn tốt nếu muốn có một hệ điều hành nhẹ và muốn hiểu về Linux.
 - openSUSE
   - Được tạo ra bởi dự án openSUSE. Là bản phân phố Linux lâu đời thứ hau vẫn đang chạy và chia sẻ hệ thống cơ sở.
   - Sử dụng trình quản lý gói RPM.
   - Là lựa chọn tuyệt vời cho người mới dùng Linux. Cung cấp một trình cài đặt, ứng dụng quản trị đồ hoạ dễ sử dụng và một hệ thống cơ sở hàng ngày dễ sửa chữa. Bao gồm mọi thứ để tận hưởng Internet không lo virus hay các phần mềm gián điệp.
   - openSUSE Leap hoàn toàn có khả năng được sử dụng trên PC và laptop.

## 2. Command Line
 - The Shell
   - Là chương trình lấy các lệnh từ bàn phím và gửi tới hệ điều hành để thực hiện. Các bản phân phối sẽ mặc định là **bash shell** .
   - Sẽ tuân theo định dạng sau:
   ```
   username@hostname:current_directory
   pete@icebox:/home/pete $  
   ```
   $ ở cuối lời nhắc, các shell khác nhau sẽ có các lời nhắc khác nhau, như ví dụ trên thì $ dành cho người dùng bình thường sử dùng Bash.
   - Lệnh **echo** , lệnh **echo** chỉ in các đối số văn bản ra màn hình
   ```
   $ echo Hello World
   ```
 
 - pwd (Print Working Directory)
   - Mọi thứ trong Linux đều là một tệp, mọi tệp đều được tổ chức trong một cây thư mục phân cấp. Thư mục đầu tiên trong hệ thống tập tin được đặt tên phù hợp là thư mục gốc. Thư mục gốc có nhiều thư mục và tệp có thể lưu trữ nhiều thư mục và tệp hơn. Và đây là ví dụ về cây thư mục:
    ```
    / 
      | - bin
 
      | | - tập tin1
 
      | | - file2
 
      | - vv
 
      | | - tập tin3
 
      | `- thư mục1
 
      | | - tập tin4
 
      | `- file5
 
      | - home
 
      | - var 
     ``` 
    - Vị trí của các tệp và thư mục này được gọi là đường dẫn. Nếu có một thư mục tên là home với một thư mục bên trong có tên là abc thì đường dẫn đó sẽ là /home/abc.
    - Nếu muốn biết mình đang ở đâu hãy gõ theo lệnh sau:
      ```
      $ pwd
      ```
 - cd (Change Directory)
   - Có 2 cách để chỉ định một đường dẫn, với các đường dẫn tuyệt đối và đường dẫn tương đối
     - Đường dẫn tuyệt đối: Là đường dẫn từ thư mục gốc. Thư mục gốc thường được hiển thị dưới dạng dấu gạch chéo. Mỗi khi đường dẫn bắt đầu bằng / thì sẽ là đang bắt đầu từ thư mục gốc. Ví dụ: / home / truong / Desktop.
     - Đường dẫn tương đối: Là đường dẫn từ nơi hiện tại ở trong hệ thống tệp. 
   - Ví dụ
     ```
     $ cd / home / truong / Hình ảnh
     ```
   - Hiện tại đã thay đổi vị trí thư mục thành / home / truong / Hình ảnh. Ví dụ như đã có một thư mục bên trong tên là abc thì có thể điều hướng bằng lệnh
     ```
     $ cd abc
     ```
   - Có một số phím tắt để giúp điều hướng nhanh hơn
     - . (Thư mục hiện tại): Là thư mục hiện đang ở.
     - .. (Thư mục mẹ): Đưa tới thư mục phía trên của hiện tại.
     - ~ (Thư mục chính): Mặc định là thư mục chính.
     - - (Thư mục trước): Đưa tới thư mục trước đó vừa ở.
     ```
     $ cd.
     $ cd ..
     $ cd ~
     $ cd -
     ```
 
 - ls (List Directories)
   - Là lệnh liệt kê nội dung thư mục 
     ```
     $ ls
     $ ls / home / pete
     ```
   - Để liệt kê các tệp ẩn sử dụng lệnh
     ```
     $ ls -a
     ```
   - Liệt kê các tệp ở định dạng dài, hiển thị thông tin chi tiết
     ```
     $ ls -l
     ```
   - Liệt kê đầy đủ 
     ```
     $ ls -la
     ```
 
 - touch
   - Cho phép tạo các tệp trống mới
     ```
     $ touch mysuperduperfile
     ```
   - Ngoài ra cũng có thể được sử dụng để thay đổi dấu thời gian trên các tệp và thư mục. Thực hiện ls -l trên một tệp và ghi lại dấu thời gian, sau đó sử dụng touch trên tệp đó sẽ cập nhật dấu thời gian.
 - file
   - Hiển thị mô tả về nội dung của tệp sử dụng lệnh
     ```
     $ file banana.jpg
     ```
 
 - cat
   - Cho phép người dùng tạo một hoặc nhiều file, xem nội dung file
     ```
     $ cat dogfile birdfile
     ```
 
 - less
   - Cho phép điều hướng thông qua các nội dung tập tin và tìm kiếm các chuỗi.
     ```
     $ less / home / pete / Documents / text1
     ```
   - Lệnh điều hướng
     - q : Thoát
     - Điều hướng bằng các phím mũi tên
     - g : chuyển đến đầu tệp văn bản
     - G : chuyển đến cuối tệp văn bản
     - / search : tìm kiếm văn bản cụ thể bên trong tài liệu, luôn có / trước các từ muốn tìm kiếm
     - h : gọi trợ giúp
 
 - history
   - Thực hiện lệnh để xem lại lệnh đã dùng trước đó
     ```
     $ history
     ```
   - Dọn dẹp màn hình 
     ```
     $ clear
     ```
 
 - cp (Copy)
   - Sao chép tệp mycoolfile vào cooldocs
     ```
     $ cp mycoolfile / home / pete / Documents / cooldocs
     ```
   - Sử dụng các kí tự giúp công việc linh hoạt hơn
     - * : dùng để đại diện cho tất cả các kí tự đơn hoặc bất kỳ chuỗi nào.
     - ? : được sử dụng để đại diện cho một ký tự.
     - [] : được sử dụng để đại diện cho bất kỳ kí tự nào trong dấu ngoặc.
       ```
       $ cp * .jpg / home / pete / Pictures
       ```
   - Sử dụng -r để sao chép các tệp và thư mục trong một thư mục
     ```
     $ cp -r Pumpkin / / home / pete / Documents
     ```
   - Sử dụng -i để nhắc người dùng trước khi ghi đè tệp
     ```
     $ cp -i mycoolfile / home / pete / Pictures
     ```
 
 - mv (Move)
   - Sử dụng để di chuyển các tệp và cũng có thể đổi tên chúng
   - Đổi tên tệp ``` $ mv oldfile newfile ```
   - Di chuyển tệp đến thư mục khác ``` $ mv file2 / home / pete / Documents ```
   - Di chuyển nhiều tệp ``` $ mv file_1 file_2 / somedirectory ```
   - Đổi tên các thư mục ``` $ mv directory1 directory2 ```
   - Sử dụng -i để nhắc trước khi ghi đè ``` mv -i directory1 directory2 ```
   - Nếu muốn ghi đè tệp trước đó, có thể tạo bản sao lưu của tệp đó và nó sẽ chỉ đổi tên phiên bản cũ bằng dấu ~ ``` $ mv -b directory1 directory2 ```
 
 - mkdir (Make Directory)
   - Lệnh tạo thư mục, có thể tạo nhiều thư mục cùng lúc ``` $ mkdir books paintings ```
   - Dùng -p để có thể tạo thư mục con ``` $ mkdir -p books / hemmingway / favorites ```
 
 - rm (Remove)
   - Sử dụng đẻ xoá tệp và thư mục ``` $ rm file1 ```
   - Xoá nhiều tệp sử dụng -f ``` $ rm -f file1 ```
   - Thêm -i để tạo nhắc nhở có muốn xoá hay không ``` $ rm -i file ```
   - Thêm -r để có thể xoá tất cả các tệp và bất kỳ thư mục con nào mà nó có thể có ``` $ rm -r directory ```
   - Xoá thư mục ``` $ rmdir directory ```
 
 - find
   - Tìm kiếm các tệp trên hệ thống ``` $ find / home -name puppies.jpg ```
   - Sẽ phải chỉ định thư mục sẽ tìm kiếm 
   - Chỉ định loại tệp đang tìm ``` $ find / home -type d -name MyFolder ```
   
 - help
   - Lệnh chạy trợ giúp
   - Cung cấp mô tả và tuỳ chọn có thể sử dụng khi chạy echo ```  $ help echo ```
   - Đối với các chương trình thực thi khác, quy ước phải có một tuỳ chọn --help ``` $ echo --help ```
   
 - man
   - Xem hướng dẫn sử dụng của ls bằng lệnh ``` $ man ls ```    
   
 - whatis
   - Là lệnh cung cấp mô tả ngắn gọn về chương trình dòng lệnh 
   - Mô tả về chương trình dòng lệnh cat ```  $ whatis cat ```
 
 - alias
   - Tạo bí danh cho 1 lệnh, chỉ cần chỉ định tên bí danh và đặt nó thành lệnh
   - ví dụ thay vì gõ ls-la thì ta gõ foobar nó sẽ thực thi lệnh ``` $ alias foobar = 'ls -la' ```
   - Nếu muốn nó tồn tại sau khi khởi động lại ``` ~ / .bashrc ```
   - Xoá bí danh ``` unalias foobar ```
   
 - exit 
   - Thoát ta sẽ nhập lệnh ``` $ exit ```
   - Lệnh đăng xuất ``` $ logout ```  

## 3. Text-Fu
 - stdout (Standard Out)
   - Chuyển hướng nối đầu ra vào một tệp như ví dụ ``` $ echo Hello World > peanuts.txt ``` file text peanuts.txt sẽ có nội dung Hello World.
   - Ở đây, > là toán tử chuyển hướng cho phép thay đổi đầu ra tiêu chuẩn. Thay vì đưa ra màn hình thì khi sử dụng > nó sẽ đưa đầu ra vào tệp.
   - Nếu không muốn ghi đè thì ta sẽ sử dụng toán tử >> thay vì >.
   
 - stdin (Standard In)
   - Tương tự stdout thì stdin sẽ dùng toán tử < để chuyển hướng.
   - Ví dụ ``` $ cat < peanuts.txt > banana.txt ``` ở đây peanuts.txt được chuyển hướng thành stdin. Và đầu ra bên trong tệp peanuts.txt sẽ được chuyển hướng tới file mới là banana.txt.
   
 - stderr (Standard Error)
   - Ví dụ liệt kê nội dung của thư mục không tồn tại và chuyển hướng kết quả đầu ra tới tệp peanuts.txt ``` $ ls /fake/directory > peanuts.txt ``` và kết quả hiển thị như sau ``` ls: cannot access /fake/directory: No such file or directory ```
   - Lí do lỗi vậy là đã gặp lỗi tiêu chuẩn, vậy nên sẽ cần chuyển hướng đầu ra theo một cách khác.
   - Cần sử dụng bộ mô tả tệp, bộ mô tả tệp là một số không âm được sử dụng để truy cập tệp hoặc luồng. Bộ mô tả tệ cho stdin, stdout, stderr lần lượt là 0,1,2.
   - Để chuyển hướng ta sẽ sử dụng như sau: ``` $ ls /fake/directory 2> peanuts.txt ``` , Sẽ chỉ nhìn thấy các thông báo stderr trong peanuts.txt.
   - Để xem cả nội stderr và stout trong peanuts.txt sẽ thực hiện ``` $ ls /fake/directory > peanuts.txt 2>&1 ```. Thao tác này sẽ gửi kết quả của ls/fake/ đến peanuts.txt sau đó chuyển hướng stderr đến stdout qua 2>&1.
   - Chuyển hướng stdout và stderr đến một tệp ``` $ ls /fake/directory &> peanuts.txt ```
   - Loại bỏ các tin thông báp stderr thì sẽ cần chuyển hướng đầu ra đếp tệp đặc biệt ``` $ ls / fake / directory 2> / dev / null ```
   
 - pipe and tee
   - Hiển thị danh sách dài các mục ``` $ ls -la /etc ```
   - Hiển thị các mục như danh sách sẽ ngắn gọn hơn ``` $ ls -la /etc | less ```
   - Toán tử pipe biểu thị bằng | , cho phép lấy đoạn mã của một lệnh và chuyển đoạn lệnh đó sang một quá trình khác.
   - Muốn viết đàu ra của lệnh vào 2 luồng khác nhau, thực hiện lệnh tee ``` $ ls | tee peanuts.txt ``` Kết quả đàu ra của ls trên màn hình và nếu mở tệp sẽ thấy thông tin tương tự trên màn hình.
   
 - env (Environment)
   - ``` $ echo $HOME ``` sẽ thấy đường dẫn đến thư mục của mình.
   - ``` $ echo $ USER ``` sẽ thấy tên người dùng.
   - ``` $ env ``` xuất ra các thông tin về các biến môi trường mà đã được cài đặt. Các biến này chứa thông tin mà shell và các quy trình có thể sử dụng, ví dụ:
     ```
     PATH = / usr / local / sbin: / usr / local / bin: / usr / sbin: / bin
     PWD = / home / user
     USER = pete
     ```
   - Biến PATH có thể truy cập bằng cách $ ở trước tên biến 
     ```
     $ echo $ PATH
     / usr / local / sbin: / usr / local / bin: / usr / sbin: / bin
     ```
   - Trả về một danh sách các đường dẫn được phân tách bằng dấu : mà hệ thống sẽ tìm kiếm khi nó chạy một lệnh.
   
 - cut
   - ``` $ echo 'The quick brown; fox jumps over the lazy  dog' > sample.txt ```, thêm tab vào giữa lazy và dog
   - Trích xuất các văn bản từ một tệp ta sử dụng lệnh cut
   - Trích xuất nội dung theo danh sách các ký tự ``` $ cut -c 5 sample.txt ``` , xuất ra ký tự thứ 5 trong mỗi dòng của tệp.
   - ``` $ cut -f 2 sample.txt ``` , -f cắt văn bản dựa trên các trường. Đầu ra sẽ là dog vì được phân tách các trường bởi tab.
   - ``` $ cut -f 1 -d ";" sample.txt ``` Thay đổi dấu phân tách tab thành dấu ";" do đó kết quả là the quick brown do cắt trường đầu tiên.
 
 - paste
   - Tương tự như cat, nó sẽ kết hợp các dòng với nhau trong tệp
     ```
     sample2.txt
     The
     quick
     brown
     fox
     ```
   - Kết hợp các dòng trên thành một dòng ``` $ paste -s sample2.txt ```
   - Dấu phân tách mặc định để dán là Tab, thay đổi dấu phân tách cho dễ đọc bằng -d ``` $ paste -d '' -s sample2.txt ``` , kết quả sẽ là mọi thứ nằm trên một dòng và được phân tách bằng dấu cách.
   
 - head 
   - Hiển thị 10 dòng đầu tiên trong tệp thay vì tất cả ``` $ head /var/log/syslog ```
   - Có thể sửa đổi số dòng bằng bất kì điều gì mong muốn, ví dụ sửa muốn xem 15 dòng đầu tiên ``` $ head -n 15 / var / log / syslog ``` , -n là viết tắt của số dòng.
   
 - tail
   - Tương tự head thì tail sẽ cho phép xem 10 dòng cuối cùng của tệp theo mặc định ``` $ tail / var / log / syslog ```
   - Có thể thay đổi số dòng muốn xem ``` $ tail -n 10 / var / log / syslog ```
   - Sử dụng -f để theo dõi tệp khi nó phát triển. Cung cấp và xem nhữn gì xảy ra ``` $ tail -f / var / log / syslog ```
   
 - expand and unexpand
   - Về mặc định sẽ luôn là Tab được sử dụng nhưng nếu muốn thay Tab thành dấu cách ta sử dụng lệnh expand ``` $ expand sample.txt ``` , sẽ in đầu ra với mỗi tab được chuyển đổi thành khoảng trống để lưu đầu ra trong 1 tệp ta sẽ sử dụng chuyển hướng đầu ra ``` $ expand sample.txt> result.txt ```
   - Để chuyển đổi ngược lại từ dấu cách thành tab ta thực hiện lệnh unexpand ``` unexpand -a result.txt ```
   
 - join and split
   - Cho phép kết nối nhiều tệp với nhau bằng một trường chung
     ```
     file1.txt
     1 John
     2 Jane
     3 Mary

     file2.txt
     1 Doe
     2 Doe
     3 Sue

     $ join file1.txt file2.txt
     1 John Doe
     2 Jane Doe
     3 Mary Sue
     ```
   - Để kết nối khi không giống nhau ta sẽ sử dụng
     ```
     $ join -1 2 -2 1 file1.txt file2.txt
     1 John Doe
     2 Jane Doe
     3 Mary Sue
     ```
   - Sử dụng lệnh tách để chia 1 tệp thành các tệp khác nhau ``` $ split somefile ```
   
 - sort
   - $ sort file1.txt : sắp xếp theo chữ cái đầu dòng
   - $ sort -r file1.txt : sắp xếp ngược lại
   - $ sort -n file1.txt : sắp xếp theo giá trị số
   
 - tr (Translate)
   - Cho phép dịch một bộ ký tự thành bộ ký tự khác, ví dụ dịch từ ký tự thường sang ký tự in hoa ``` $ tr az AZ ```
 
 - uniq (Unique)
   - Lệnh để phân tích cú pháp văn bản
   - Ví dụ têp có nhiều bản sao sẽ dùng lệnh uniq để xoá bản sao ``` $ uniq reading.txt ```
   - Tính xem số lần xuất hiện ``` $ uniq -c reading.txt ```
   - Lấy các giá trị duy nhất ``` $ uniq -u reading.txt ```
   - Lấy các giá trị trùng lặp ``` $ uniq -d reading.txt ```  
   - uniq không phát hiện các dòng trùng trừ khi chúng ở gần nhau, do đó để khắc phục ta sẽ sử dụng sort kết hợp với uniq ``` $ sort reading.txt | uniq ```
   
 - wc and nl 
   - wc sẽ hiển thị tổng số từ trong một tệp ``` $ wc /etc/passwd ``` , hiển thị số dòng, số từ và số byte tương ứng.
   - Sử dụng -l, -w, -c để xem số lượng của mỗi trường nhất định.
   - Có thể sử dụng nl để kiểm tra số dòng trên tệp ``` $ nl file1.txt ```
   
 - grep
   - Cho phép bạn tìm kiếm các tệp cho các ký tự phù hợp với một mẫu nhất định ``` $ grep fox sample.txt ``` tìn fox trong sample.txt
   - Phân biệt các mẫu chữ hoa chữ thường với -i ``` $ grep -i somepattern somefile ```
   - Kết hợp với các lệnh khác bằng | ``` $ env | grep -i User ```
   - ``` $ ls / somedir | grep '.txt $' ``` Trả về các tệp kết thúc bằng .txt xong somedir.  
 
## 4. Advanced Text-Fu
 - regrex (Regular Expressions)
   - Biểu thức chính quy sử dụng ký tự 
     ```
     sally sells seashells 
     by the seashore
     ```
   - Bắt đầu bằng ^ ``` ^by ``` kết quả sẽ khớp là by the seashore.
   - Kết thúc bằng $ ``` seashore$ ``` kết quả sẽ khớp là by the seashore.
   - So khớp với bất kì ký tự đơn nào với . ``` b. ``` sẽ phù hợp với by.
   - Có ký hiệu [] ``` d [iou] g ``` sẽ khớp với dig, dog, dug.
   - Có ^ trước ký tự trong [] là tất cả những gì ngoài dấu ngoặc.
   - Ngoài ra dấu [] cũng giúp tăng phạm vi số lượng ký tự muốn sử dụng ``` d [a-c] g ```
   - Dấu ngoặc phân biệt chữ hoa và chữ thường.
   
 - Text Editors
   - Vim và emacs là những trình soạn thảo văn bản phổ biến được cài đặt mặc định trên hầu hết các bản phân phối Linux và cả 2 đều có ưu và nhược điểm riêng.
   - Chúng là mã hoá, xử lý tài liệu văn bản và về cơ bản là tất cả trong một trình soạn thảo.
   
 - Vim (Vi Improved)
   - Là viết tắt của phiên bản cải tiến của lệnh soạn thảo văn bản vi.
   - Siêu nhẹ, việc mở và chỉnh sủa tệp bằng vim nhanh chóng và dễ dàng, gần như luôn có sẵn.
   - Để kích hoạt chỉ cần gõ ``` vim ```
   
 - Vim Search Patterns
   - Khi cần tìm kiếm chỉ cần nhập / sau đó nhập kết quả tìm kiếm khi đang ở trong vim. Sau khi enter có thể ấn n để tiến và N để lùi 
   - Có thể dùng ? để tìm kiếm ngược so với /
   
 - Vim Navigation
   - Để điều hướng trong vim ta sử dụng các phím sau:
     ```
     h hoặc mũi tên trái để di chuyển sang trái
     k hoặc mũi tên lên để di chuyển lên dòng trên
     j hoặc mũi tên xuống để di chuyển xuống dòng dưới
     l hoặc mũi tên phải để di chuyển sang phải
     ```
 - Vim Appending Text
   - Khi đang ở chế độ lệnh sẽ không thể nhập được, để có thể nhập thì trước tiên ta sẽ cần vào chế độ chèn
   - Gõ i : chèn văn bản trước con trỏ
   - Gõ O : chèn văn bản trên dòng trước
   - Gõ o : chèn văn bản vào dòng tiếp theo
   - Gõ a : nối văn bản sau con trỏ
   - Gõ A : nối văn bản vào cuối dòng
   - Để thoát khoải chế độ chèn và quay lại chế độ lệnh, sử dụng phím Esc
   
 - Vim Editing
   - Để có thể chỉnh sửa trong vim ta sẽ có những phím sau đây
   - x : dùng để cắt văn bản đã chọn hay cũng được sử dụng để xóa các ký tự
   - dd : dùng để xóa dòng hiện tại
   - y : kéo hoặc sao chép bất cứ thứ gì được chọn
   - yy : kéo hoặc sao chép dòng hiện tại
   - p : dán văn bản đã sao chép trước con trỏ
   
 - Vim Saving and Exiting
   - Để có thể lưu và thoát khỏi vim ta sẽ thực hiện như sau
   - :w : dùng để ghi hoặc lưu tệp
   - :q : dùng để thoát khỏi vim
   - :wq : viết sau đó thoát khỏi vim
   - :q! : thoát khỏi vim mà không lưu tệp
   - ZZ : tương đương với :wq, nhưng nhanh hơn
   - u : hoàn tác hành động cuối cùng của bạn
   - Ctrl + r : thực hiện lại hành động cuối cùng
   
 - Emacs
   - Dành cho những người dùng muốn có trình soạn thảo văn bản cực kỳ mạnh mẽ, có thể thực hiện tất cả việc chỉnh sửa mã, thao tác tệp...
   - Để bắt đầu chỉ cần gõ ``` emacs ```
   - Bộ đệm trong emacs là nơi chứa văn bản. Vì vậy, nếu mở một tệp, bộ đệm sẽ được sử dụng để lưu trữ nội dung của tệp đó. Có thể mở nhiều bộ đệm cùng lúc và có thể dễ dàng chuyển đổi giữa các bộ đệm.
   
 - Emacs Manipulate Files
   - Để lưu tệp
     - C-x C-s : Lưu tệp
     - C-x C-w : Lưu tệp dưới dạng
     - C-x s : Lưu tất cả
   - Mở tệp
     - C-x C-f         
 
 - Emacs Buffer Navigation
   - Để di chuyển xung quanh bộ đẹp, ta sử dụng các lệnh sau
   - Chuyển đổi bộ đệm
     - C-x b : chuyển đổi bộ đệm
     - C-x right arrow : di chuyển sang phải bộ đệm
     - C-x left arrow : di chuyển sang trái bộ đệm
   - Đóng bộ đệm
     - C-x k
   - Tách bộ đệm hiện tại
     - C-x 2 
   - Đặt một bộ đệm duy nhất làm màn hình hiện tại           
     - C-x 1
 
 - Emacs Editing
   - Điều hướng văn bản
     ```
     C-up arrow : di chuyển lên một đoạn
     C-down arrow: di chuyển xuống một đoạn
     C-left arrow: di chuyển một từ sang trái
     C-right arrow: di chuyển một từ sang phải
     M-> : di chuyển đến cuối vùng đệm
     ```
   - Cắt và dán
     - Trước tiên cần phải chọn văn bản, di chuyển con trỏ đến nơi muốn cắt hoặc dán sau đó nhấn ``` C-space key ```
     - Sau đó có thể cắt và dán bằng cách C-w : cắt, C-y : dán.
 
 - Emacs Exiting and Help
   - Để đóng Emacs ``` C-x C-c ```
   - Cần trợ giúp ``` C-h C-h : help menu ```
   - Hoàn tác ``` C-x u ```
 
## 5. User Management 
 - Users and Groups
   - Trong bất kỳ hệ điều hành truyền thống nào, đều có người dùng và nhóm. Chúng chỉ tồn tại cho quyền truy cập và quyền.
   - Mỗi người dùng có thư mục chính của riêng họ, nơi các tệp người dùng cụ thể của họ được lưu trữ, thư mục này thường nằm trong / home / username, nhưng có thể khác nhau trong các bản phân phối khác nhau.
   - Hệ thống sử dụng mã người dùng (UID) để quản lý người dùng, tên người dùng là cách thân thiện để liên kết người dùng với nhận dạng, nhưng hệ thống xác định người dùng bằng UID của họ. Hệ thống cũng sử dụng nhóm để quản lý quyền, nhóm chỉ là tập hợp người dùng có quyền do nhóm đó thiết lập, họ được hệ thống xác định bằng ID nhóm (GID) của họ.
   - Trong Linux, bạn sẽ có người dùng ngoài những người bình thường sử dụng hệ thống. Đôi khi những người dùng này là daemon hệ thống liên tục chạy các quy trình để giữ cho hệ thống hoạt động. Một trong những người dùng quan trọng nhất là root hoặc superuser, root là người dùng mạnh nhất trên hệ thống, root có thể truy cập bất kỳ tệp nào và bắt đầu và kết thúc bất kỳ quá trình nào.
   - Để có thể chạy với quyền root sử dụng lệnh ``` sudo ```
   
 - root
  - Có thể chạy các lệnh với tư cách là superuser bằng lệnh ``` su ```. Lệnh này sẽ "thay thế người dùng" và mở trình bao gốc nếu không có tên người dùng nào được chỉ định. Bạn có thể sử dụng lệnh này để thay thế cho bất kỳ người dùng nào miễn là bạn biết mật khẩu.
  - Có một tệp được gọi là tệp / etc / sudoers, tệp này liệt kê những người dùng có thể chạy sudo. Có thể chỉnh sửa tệp này bằng lệnh ``` visudo ``` . 
  
- /etc/passwd
  - Hệ thống sử dụng ID người dùng (UID) để xác định người dùng. Để biết người dùng được ánh xạ tới ID nào, hãy xem tệp / etc / passwd. ``` $ cat / etc / passwd ```
  - Tệp này hiển thị danh sách người dùng và thông tin chi tiết về họ. Ví dụ: dòng đầu tiên trong tệp này rất có thể trông giống như sau:
    ```
    root:x:0:0:root:/root:/bin/bash
    ```
  - Mỗi dòng hiển thị thông tin người dùng cho một người dùng, thông thường nhất sẽ thấy người dùng root là dòng đầu tiên. Có nhiều trường được phân tách bằng dấu hai chấm cho biết thông tin bổ sung về người dùng.
    - Tên tài khoản
    - Mật khẩu người dùng
    - ID người dùng, như trên root có UID là 0
    - ID nhóm
    - GECOS : được dùng để để lại nhận xét về người dùng hoặc tài khoản 
    - Thư mục chỉnh sửa của người dùng
    - Trình bao của người dùng
  - có thể chỉnh sửa tệp / etc / passwd bằng tay nếu muốn thêm người dùng và sửa đổi thông tin bằng công cụ vipw.

- /etc/shadow
  - Tệp / etc / shadow được sử dụng để lưu trữ thông tin về xác thực người dùng. Nó yêu cầu quyền đọc siêu người dùng.
    ```
    $ sudo cat / etc / shadow
    root: MyEPTEa $ 6Nonsense: 15000: 0: 99999: 7 :::
    ```
  - Nó trông rất giống với nội dung của / etc / passwd, tuy nhiên trong trường mật khẩu, sẽ thấy một mật khẩu được mã hóa. Các trường được phân tách bằng dấu hai chấm như sau:
    - Tên tài khoản
    - Mật khẩu được mã hóa
    - Ngày thay đổi mật khẩu cuối cùng - được biểu thị bằng số ngày kể từ ngày 1/1/1970
    - Độ tuổi mật khẩu tối thiểu
    - Tuối mật khẩu tối đa
    - Khoảng thời gian cảnh báo mật khẩu
    - Khoảng thời gian không hoạt động của mật khẩu
    - Ngày hết hạn tài khoản
    - Trường dành riêng để sử dụng trong tương lai

- /etc/group  
  - Một tệp khác được sử dụng trong quản lý người dùng là tệp / etc / group. Tệp này cho phép các nhóm khác nhau với các quyền khác nhau.
    ``` $ cat /etc/group ```
  - Bao gồm các trường: ``` root:*:0:pete ```
    - Tên nhóm
    - Mật khẩu nhóm
    - ID nhóm
    - Danh sách người dùng  

- User Management Tools
  - Hầu hết các môi trường doanh nghiệp đang sử dụng hệ thống quản lý để quản lý người dùng, tài khoản và mật khẩu. Tuy nhiên, trên một máy tính đơn lẻ có các lệnh hữu ích để chạy để quản lý người dùng.
  - Thêm người dùng sử dụng lệnh adduser hoặc useradd ``` $ sudo useradd bob ```
  - Xóa người dùng sử dụng lệnh userdel ``` $ sudo userdel bob ```
  - Đổi password sử dụng ``` $ passwd bob ```

## 6. Permissions
 - File Permissions
   - Ví dụ
     ```
     $ ls -l Desktop/
     drwxr-xr-x 2 pete penguins 4096 Dec 1 11:45 .
     ```
   - Có 4 phần đối với phân quyền của tệp
     - Đầu tiên là loại tệp
     - 3 phần tiếp theo là các quyền, các quyền được nhóm thành 3 bit mỗi quyền, 3 bit đầu là quyền của người dùng, sau là quyền nhóm và cuối cùng là các quyền khác
     - ``` d | rwx | r-x | r-x ```
     - Mỗi kí tự đại diện cho mỗi quyền khác nhau: r: có thể đọc được, w: có thể ghi, x: thi hành, -: làm rỗng 
 - Modifying Permissions
   - Thay đổi quyền có thể dễ dàng thực hiện bằng lệnh ** chmod **
   - Đầu tiên, hãy chọn nhóm quyền bạn muốn thay đổi, người dùng, nhóm hoặc nhóm khác. Bạn có thể thêm hoặc xóa quyền bằng dấu + hoặc - 
   - Ví dụ : ``` $ chmod u+x myfile ``` Lệnh có nội dung như sau: thay đổi quyền trên myfile bằng cách thêm bit quyền thực thi trên tập người dùng. Vì vậy, bây giờ người dùng có quyền thực thi trên tệp này
   - Xóa bit quyền trên một tệp ``` $ chmod u-x myfile ```
   - Thêm nhiều bit quyền trên một tệp ``` $ chmod ug+w ``` .  Có một cách khác để thay đổi quyền sử dụng định dạng số. Phương pháp này cho phép bạn thay đổi các quyền cùng một lúc. Thay vì sử dụng r, w hoặc x để biểu thị các quyền, bạn sẽ sử dụng một biểu diễn số cho một tập hợp quyền duy nhất. Vì vậy, không cần chỉ định nhóm với g hoặc người dùng với u.
     - Các biểu diễn số như sau: 4: quyền đọc, 2: quyền viết, 1 quyền thực thi.
     - Ví dụ: ``` $ chmod 755 myfile ``` 
 
 - Ownership Permissions
   - Cũng có thể sửa đổi quyền sở hữu của nhóm và người dùng đối với tệp
   - Sửa đổi quyền sở hữu của người dùng ``` $ sudo chown patty myfile ``` . Lệnh sẽ đặt chủ sở hữu của mylife thành patty,
   - Sửa đổi quyền sở hữu nhóm ``` $ sudo chgrp whales myfile ``` . Lệnh sẽ đặt nhóm mylife thành whales.
   - Sửa đổi quyền sở hữu người dùng và nhóm cùng một lúc. Nếu thêm : và tên nhóm sau người dùng thì có thể đặt cả người dùng và nhóm cùng một lúc ``` $ sudo chown patty:whales myfile ```
 
 - Umask
   - Muốn thay đổi bộ quyền mặc định, có thể làm như vậy bằng lệnh umask. Lệnh này sử dụng bộ quyền 3 bit mà chúng ta thấy trong các quyền số.
   - Thay vì thêm các quyền này, umask sẽ lấy đi các quyền này ``` $ umask 021 ```
   
 - Setuid
   - Set User ID (SUID) cho phép người dùng chạy chương trình với tư cách là chủ sở hữu của tệp chương trình chứ không phải với tư cách là chính họ.
   - Sửa đổi SUID, Có 2 cách sửa đổi các quyền SUID:
     - Cách tượng trưng : ``` $ sudo chmod u+s myfile ```
     - Cách số : ``` sudo chmod 4755 myfile ```
   - SUID có ký hiệu là 4 và được cấp trước cho tập hợp quyền.  
 
 - Setgid
   - Tương tự như bit quyền ID người dùng đã đặt, có một bit quyền ID nhóm (SGID) đã đặt. Bit này cho phép một chương trình chạy như thể nó là một thành viên của nhóm đó.
   - Sửa đổi SGID 
     - Cách tượng trưng : ``` $ sudo chmod g+s myfile ```
     - Cách số : ``` $ sudo chmod 2555 myfile ```
   - SGID có số ký hiệu là 2.  
   
 - Process Permissions
   - khởi chạy một quy trình, quy trình sẽ chạy với các quyền tương tự như người dùng hoặc nhóm đã chạy nó, đây được gọi là effective user ID. UID này được sử dụng để cấp quyền truy cập cho một quy trình.    
   - Có một UID khác, được gọi là real user ID , đây là ID của người dùng đã khởi chạy quy trình. Chúng được sử dụng để theo dõi người dùng đã khởi chạy quy trình là ai.
   - Một UID cuối cùng là saved user ID, điều này cho phép quá trình chuyển đổi giữa UID hiệu quả và UID thực, ngược lại.
   
 - The Sticky Bit
   - Bit quyền này, "sticks a file/directory", điều này có nghĩa là chỉ chủ sở hữu hoặc người dùng root mới có thể xóa hoặc sửa đổi tệp. Điều này rất hữu ích cho các thư mục được chia sẻ.
   - ví dụ :
      ```
      $ ls -ld /tmp
      drwxrwxrwxt 6 root root 4096 Dec 15 11:45 /tmp
      ```
      Một bit quyền đặc biệt t ở cuối, nghĩa là mọi người đều có thể thêm tệp, ghi tệp, sửa đổi tệp trong thư mục tmp nhưng chỉ root mới có thể xóa thư mục,
   - Sửa đổi bit dính
     - Dạng tượng trưng : ``` $ sudo chmod +t mydir ```
     - Dạng số : ``` $ sudo chmod 1755 mydir ```
   - Số ký tự của bit dính là 1.
 
## 7. Processes 
 - ps (Processes)
   - Quy trình là các chương trình đang chạy trên máy của bạn. Chúng được quản lý bởi hạt nhân và mỗi tiến trình có một ID được liên kết với nó được gọi là process ID (PID). PID này được chỉ định theo thứ tự các quá trình được tạo. 
   - Chạy lệnh ps
     ```
     $ ps
     PID TTY STAT TIME CMD
     41230 pts / 4 S 00:00:00 bash
     51224 pts / 4 R + 00:00:00 ps
     ```
     PID : ID quy trình
     TTY : kiểm soát thiết bị đầu cuối liên quan đến quy trình
     STAT: Mã trạng thái quy trình
     TIME: Tổng thời gian sử dụng CPU
     CMD : Tên của lệnh (Lệnh thực thi)
   - Lệnh ``` $ ps aux ``` , a : các quá trình đang chạy, u : hiển thị chi tiết hơn các quy trình, x : liệt kê các quy trình không có TTY liên kết với nó, các quy trình này sẽ hiển thị ? trong trường TTY.
   - Lệnh ``` $ top ``` , cung cấp thông tin thời gian thực về các tiến trình đang chạy trên hệ thống, theo mặc định thì sẽ được làm mới sau mỗi 10s.
   
 - Controlling Terminal
   - TTY là thiết bị đầu cuối thực hiện lệnh.
   - Có 2 loại thiết bị đầu cuối
     - terminal devices: là thiết bị đầu cuối nguyên bản có thể nhập và gửi đàu ra tới hệ thống.
     - pseudoterminal devices: mô phỏng các thiết bị đầu cuối với cửa sổ đầu cuối shell và được ký hiệu là PTS.
   - Các quy trình thường bị ràng buộc với một thiết bị đầu cuối điều khiển. 
   - Trong đầu ra ps, TTY được liệt kê là ? nghĩa là nó không có thiết bị đầu cuối điều khiển.
   
 - Process Details 
   - Kernel phụ trách các quá trình, khi chạy một chương trình, hạt nhân sẽ tải mã của chương trình đó vào bộ nhớ, xác định và phân bổ tài nguyên rồi giữ các tab trên mỗi quá trình, nó biết:
     - Tình trạng của quá trình
     - Các tài nguyên mà quá trình đang sử dụng và nhận được
     - Chủ sở hữu quy trình
     - Xử lí tín hiệu
     - Mọi thứ khác
   - Công việc của kernel là đảm bảo rằng các quy trình nhận được lượng tài nguyên phù hợp tùy thuộc vào nhu cầu của quy trình. Khi một quá trình kết thúc, các tài nguyên mà nó đã sử dụng sẽ được giải phóng cho các quá trình khác.
   
 - Process Creation
   - Khi một quy trình mới được tạo, một quy trình hiện tại về cơ bản sẽ tự sao chép bằng cách sử dụng một thứ gọi là lệnh gọi hệ thống rẽ nhánh.
   - Lệnh gọi hệ thống rẽ nhánh tạo ra một quy trình con gần như giống hệt nhau, quy trình con này nhận một ID quy trình mới (PID) và quy trình gốc trở thành quy trình mẹ của nó và có một cái gì đó được gọi là ID quy trình mẹ PPID.
   - Tiến trình con có thể tiếp tục sử dụng cùng một chương trình mà cha mẹ của nó đã sử dụng trước đó hoặc thường xuyên hơn sử dụng lệnh gọi hệ thống thực thi để khởi chạy một chương trình mới.     
   - Lệnh gọi hệ thống này phá hủy việc quản lý bộ nhớ mà hạt nhân đưa vào cho quá trình đó và thiết lập các bộ nhớ mới cho chương trình mới.
     ```
     $ ps l
     ```
   - Tùy chọn l cung cấp chế độ xem định dạng dài, chi tiết hơn về các quy trình đang chạy. Cột có nhãn PPID là ID mẹ.
   - Khi hệ thống khởi động, các hạt nhân tạo ra một tiến trình gọi là init , nó có PID là 1. Tiến trình init không thể kết thúc trừ khi hệ thống tắt. Nó chạy với đặc quyền root và chạy nhiều quy trình giúp hệ thống luôn hoạt động.
   
 - Process Termination
   - Một quy trình có thể thoát bằng lệnh gọi hệ thống exit , điều này sẽ giải phóng tài nguyên mà quy trình đang sử dụng để phân bổ lại. Vì vậy, khi một tiến trình sẵn sàng kết thúc, nó sẽ cho hạt nhân biết lý do tại sao nó kết thúc với một thứ gọi là trạng thái kết thúc. Thông thường nhất, trạng thái 0 có nghĩa là quá trình đã thành công. Tuy nhiên, điều đó không đủ để chấm dứt hoàn toàn một quá trình. Tiến trình mẹ phải xác nhận việc kết thúc quy trình con bằng cách sử dụng lệnh gọi của hệ thống chờ và điều này làm là nó kiểm tra trạng thái kết thúc của quy trình con. 
   - Orphan Processes: Khi tiến trình cha chết trước tiến trình con, kernel biết sẽ không nhận được lệnh chờ nó sẽ biến các tiến trình này thành orphan và đặt chúng cho init chăm sóc. Init sẽ thực hiện lệnh gọi của hệ thống chờ những tiến trình orphan này có thế chết.
   - Zombie Processes: Mặc dù tiến trình con kết thúc nhưng hạt nhân sẽ biến các tiến trình con này thành một quá trình zombie, các tài nguyên tiến trình con sử dụng vẫn được giải phóng cho tiến trình khác. Zombie processes không thể bị giết vì có thể hiểu chúng đã chết về mặt kỹ thuật. Cuối cùng nếu tiến trình cha gọi lệnh chờ hệ thống, thây ma sẽ biến mất, điều này được gọi là "gặt hái". Nếu cha mẹ không thực hiện cuộc gọi chờ, init sẽ chấp nhận zombie và tự động thực hiện chờ và loại bỏ zombie.
   
 - Signals
   - Tín hiệu là một thông báo cho một quá trình rằng điều gì đó đã xảy ra.
   - Lí do có tín hiệu
     - Người dùng có thể nhập một trong các ký tự đầu cuối đặc biệt hoặc để hủy, ngắt hoặc tạm dừng các tiến trình
     - Sự cố phần cứng có thể xảy ra và hạt nhân muốn thông báo quá trình
     - Sự cố về phần mềm có thể xảy ra và hạt nhân muốn thông báo quá trình
     - Là những cách mà quy trình có thể giao tiếp
   - Quy trình tín hiệu
     - Tín hiệu được tạo ra bởi một số sự kiện sau đó được chuyển đến một quá trình, được gọi là trạng thái chờ xử lí cho đến khi được phân phối. Khi quá trình được chạy, tính hiệu sẽ được phân phối. Tuy nhiên, các quy trình có mặt nạ tín hiệu và chúng có thể đặt việc phân phối tín hiệu bị chặn nếu được chỉ định. Khi một tín hiệu được phân phối, một quá trình có thể thực hiện vô số việc:
       - Bỏ qua tín hiệu
       - Bắt tín hiệu và thực hiện 1 quy trình xử lý cụ thể
       - Quá trình có thể được kết thúc, trái ngược với lệnh gọi hệ thống thoát bình thường.
       - Chặn tín hiệu, tùy thuộc vào mặt nạ tín hiệu
   - Tín hiệu chung
     - Mỗi tín hiệu được xác định bởi các số nguyên có tên tượng trưng có dạng SIGxxx
     - Một số tín hiệu phổ biến
       - SIGHUP hoặc HUP hoặc 1: Cúp máy
       - SIGINT hoặc INT hoặc 2: Ngắt
       - SIGKILL hoặc KILL hoặc 9: Giết
       - SIGSEGV hoặc SEGV hoặc 11: Lỗi phân đoạn
       - SIGTERM hoặc TERM hoặc 15: Chấm dứt phần mềm
       - SIGSTOP hoặc STOP: Dừng lại 
     - Một số tín hiệu không thể chặn được, một ví dụ là tín hiệu SIGKILL. Tín hiệu KILL phá hủy quá trình. 
 
 - kill (Terminate)
   - Có thể gửi các tín hiệu kết thúc quá trình, một lệnh như vậy được đặt tên hợp lý là lệnh kill. ``` $ kill 12445 ``` ,1 2445 là PID của quá trình bạn muốn kết thúc.
   - Có thể chỉ định một tính hiệu bằng lệnh kill ``` $ kill -9 12445 ```
   - Sự khác nhau giữa SIGHUP, SIGINT, SIGTERM, SIGKILL, SIGSTOP
     - SIGHUP - Cúp máy, được gửi tới một quy trình khi thiết bị đầu cuối điều khiển đóng.
     - SIGINT - Là một tín hiệu ngắt, vì vậy bạn có thể sử dụng Ctrl-C và hệ thống sẽ cố gắng kết thúc quá trình một cách nhẹ nhàng.
     - SIGTERM - Hủy quá trình, nhưng cho phép nó thực hiện một số hoạt động dọn dẹp trước.
     - SIGKILL - Giết quá trình, giết nó bằng lửa, không thực hiện bất kỳ hoạt động dọn dẹp nào.
     - SIGSTOP - Dừng / tạm ngừng quá trình.
 
 - niceness
   - Các quy trình sử dụng CPU trong một khoảng thời gian nhỏ được gọi là lát thời gian. Sau đó, chúng tạm dừng trong mili giây và một quá trình khác nhận được một lát thời gian nhỏ. Theo mặc định, lập lịch quy trình diễn ra theo kiểu tuần hoàn này. Mọi quy trình đều có đủ thời gian cho đến khi xử lý xong. Kernel xử lý tất cả các quá trình chuyển đổi này và nó thực hiện khá tốt công việc đó trong hầu hết thời gian.
   - Niceness là các tiến trình có một số để xác định mức độ ưu tiên của chúng đối với CPU. Một số cao có nghĩa là quá trình tốt và có mức độ ưu tiên thấp hơn cho CPU và số thấp hoặc âm có nghĩa là quá trình không tốt lắm và nó muốn lấy càng nhiều CPU càng tốt.
   - Để thay đổi mức độ ta sử dụng lệnh nice hoặc renice
     - ``` $ nice -n 5 apt upgrade ```
     - ``` $ renice 10 -p 3245 ```
     - Lệnh nice được sử dụng để đặt mức độ ưu tiên cho một tiến trình mới. Lệnh renice được sử dụng để đặt mức độ ưu tiên trên một quy trình hiện có.
 
 - Process States
   - Xem lệnh ``` $ ps aux ```
   - Trong cột STAT sẽ thấy rất nhiều giá trị, các mã trạng thái phổ biến nhất là:
     - R: đang chạy hoặc có thể chạy được, nó chỉ chờ CPU xử lý thôi
     - S: Chế độ ngủ gián đoạn, chờ một sự kiện hoàn thành, chẳng hạn như đầu vào từ thiết bị đầu cuối
     - D: Ngủ liên tục, các quá trình không thể bị giết hoặc bị gián đoạn bằng tín hiệu, thường để làm cho chúng biến mất, bạn phải khởi động lại hoặc khắc phục sự cố
     - Z: Zombie, chúng ta đã thảo luận trong một bài học trước rằng zombie là những tiến trình đã kết thúc đang chờ thu thập trạng thái của chúng
     - T: Đã dừng, một quá trình đã bị tạm dừng / dừng
 
 - /proc filesystem
   - Thông tin quy trình được lưu trữ trong một hệ thống tệp đặc biệt được gọi là hệ thống tệp / proc. ``` $ ls /proc ```
   - ``` $ cat /proc/12345/status ``` thông tin trạng thái quy trình và thông tin chi tiết hơn. Thư mục / proc là cách kernel xem hệ thống, vì vậy có rất nhiều thông tin ở đây hơn những gì bạn sẽ thấy trong ps.
   
 - Job Control
   - Gửi một công việc đến nền bằng cách thêm dấu & vào lệnh sẽ chạy ở chế độ nền để vẫn có thể sử dụng cửa sổ lệnh:
     ```
     $ sleep 1000 &
     $ sleep 1001 &
     $ sleep 1002 &
     ```
   - Xem các công việc nền
     ```
     $ jobs
     [1]    Running     sleep 1000 &
     [2]-   Running     sleep 1001 &
     [3]+   Running     sleep 1002 &
     ```
     Thao tác này sẽ hiển thị id công việc trong cột đầu tiên, sau đó là trạng thái và lệnh đã được chạy. Dấu + bên cạnh ID công việc có nghĩa là nó là công việc nền gần đây nhất đã bắt đầu. Công việc với - là lệnh gần đây nhất thứ hai.
   - Gửi một công việc đến nền trên công việc hiện có, nếu đã chạy một công việc và muốn gửi nó xuống nền, bạn không cần phải chấm dứt nó và bắt đầu lại. Trước tiên, hãy tạm dừng công việc bằng Ctrl-Z, sau đó chạy lệnh ``` bg ``` để gửi nó xuống nền.
   - Di chuyển công việc từ nền sang nền trước ``` $ fg %1 ```
   - Giết công việc nền ``` kill %1 ```
## 8. Packages   
 - Software Distribution
   - Hệ thống bao gồm nhiều gói như trình duyệt, trình soạn thảo, trình phát đa phương tiện,.. Các gói này sẽ được quản lý thông qua trình quản lý gói để cài đặt và duy trì phần mềm trên hệ thống.
   - Thường có thể cài đặt trực tiếp từ mã nguồn, nhưng phần lớn là sử dụng trình quản lý gói để cài đặt, các gói phổ biến là Debian (.deb), Red Hat (.rpm).
   - Những người viết các phần mềm được gọi là upstream providers, họ biên dịch mã và viết cách cài đặt, họ làm việc để đưa ra các phiên bản, phần mềm mới. Khi đã sẵn sàng phát hành, họ gửi gói tới package maintainers, những người này sẽ xử lý và đưa phần mềm tới người dùng, xem xét và quản lý phàn mềm này dưới dạng gói.
    
 - Package Repositories
   - Kho lưu trữ chỉ là một vị trí lưu trữ trung tâm cho các gói. Có rất nhiều kho chứa rất nhiều gói và tốt nhất là tất cả chúng đều được tìm thấy trên internet, không có đĩa cài đặt.
   - Thay vì truy cập trang web để tải xuống, chúng ta có thể yêu cầu máy tính tìm phần mềm từ liên kết nguồn.
   - Bản phân phối đã đi kèm với các nguồn được phê duyệt trước để lấy các gói và đây là cách nó cài đặt tất cả các gói cơ sở mà chúng ta thấy trên hệ thống của mình. Trên hệ thống Debian, tệp nguồn này là tệp /etc/apt/sources.list .
  
 - tar and gzip
   - gzip là chương trình được sử dụng để nén các tệp trong linux, chúng kết thúc bằng phần mở rộng ``` .gz ```
     - Nén tệp: ``` $ gzip mycoolfile ```
     - Giải nén: ``` $ gunzip mycoolfile.gz ```
   - gzip sẽ không thể thêm nhiều tệp vào 1 kho lưu trữ, thay vì đó chúng ta sẽ sử dụng tar. Kho lưu trữ tar sẽ có phần mở rộng .tar
     - Tạo tệp lưu trữ bằng tar ``` $ tar cvf mytarfile.tar mycoolfile1 mycoolfile2 ```
       - c: tạo
       - v: yêu cầu chương trình cho xem chúng đang làm gì
       - f: tên tệp của tệp tar phải đứng sau tùy chọn này 
     - Giải nén kho lưu trữ bằng tar ``` $ tar xvf mytarfile.tar ```
       - x: trích xuất
       - v: yêu cầu chương trình cho xem chúng đang làm gì
       - f: tệp muốn giải nén
     - Nén và giải nén các kho lưu trữ bằng tar và gzip
       - Tạo tệp tar nén: ``` $ tar czf myfile.tar.gz ```
       - Giải nén: ``` $ tar xzf file.tar ```
 
 - Package Dependencies
   - Các gói rất hiếm khi tự hoạt động, chúng thường đi kèm với các gói phụ thuộc để giúp chúng chạy.
   - Trong Linux, các phần phụ thuộc này thường là các gói khác hoặc các thư viện được chia sẻ. Thư viện dùng chung là thư viện mã mà các chương trình khác muốn sử dụng và không muốn phải viết lại cho chính mình.
   - Các gói có các phần phụ thuộc để giúp chúng chạy, cho dù các phần phụ thuộc đó là các gói hay thư viện khác, nếu các phần phụ thuộc không có ở đó thì gói sẽ bị hỏng trạng thái và hầu hết thời gian thậm chí không cài đặt. 
  
 - rpm and dpkg
   - Để cài đặt các gói trực tiếp này, có thể sử dụng các lệnh quản lý gói: rpm và dpkg. 
   - Sẽ không cài đặt các gói phụ thuộc, do vậy nếu gói có phụ thuộc thì sẽ cần cài đặt các gói riêng lẻ và sau đó là các phần phụ thuộc.
   - Cài đặt gói:
     - Debian: $ dpkg -i some_deb_package.deb
     - RPM: $ rpm -i some_rpm_package.rpm
       - i là viết tắt của install (cài đặt)   
   - Xóa gói:
     - Debian: $ dpkg -i some_deb_package.deb
     - RPM: $ rpm -e some_rpm_package.rpm
       - Debian: r để xóa
       - RPM: e để xóa
   - Liệt kê các gói đã cài đặt:
     - Debian: $ dpkg -l
     - RPM: $ rpm -qa
       - Debian: l là cho danh sách
       - RPM: q cho truy vấn và a là cho tất cả  
      
 - yum and apt
   - Các hệ thống đi kèm với tất cả các bản sửa lỗi để làm cho việc cài đặt, gỡ bỏ và thay đổi gói dễ dàng hơn, bao gồm cả việc cài đặt các gói phụ thuộc. Hai trong số các hệ thống quản lý phổ biến nhất là yum và apt . Yum dành riêng cho dòng Red Hat và apt dành riêng cho dòng Debian.
   - Cài đặt một gói từ kho lưu trữ:
     - Debian: $ apt install package_name
     - RPM: $ yum install package_name
   - Loại bỏ một gói:
     - Debian: $ apt remove package_name
     - RPM: $ yum erase package_name 
   - Cập nhật các gói cho một kho lưu trữ:
     - Debian: apt update; apt upgrade
     - RPM: yum update
   - Nhận thông tin về một gói đã cài đặt:
     - Debian: apt show package_name
     - RPM: yum info package_name      
 
 - Compile Source Code
   - Thông thường, sẽ gặp phải một gói khó hiểu chỉ xuất hiện dưới dạng mã nguồn thuần túy. Chúng ta sẽ cần sử dụng một số lệnh để gói mã nguồn đó được biên dịch và cài đặt trên hệ thống.
   - Đầu tiên sẽ cần có phần mềm để cài đặt các công cụ cho phép biên dịch mã nguồn: 
     ``` $ sudo apt install build-essential ```
   - Sau đó giải nén nội dung của tệp gói
     ``` $ tar -xzvf package.tar.gz ```
   - Trước khi làm gì đó hãy xem tệp README để xem hướng dẫn cài đặt cụ thể.
   - Bên trong nội dung gói sẽ là tập lệnh cấu hình, tập lệnh này kiểm tra các phần phụ thuộc vào hệ thống và nếu thiếu bất kỳ điều gì chúng ta sẽ thấy lỗi và cần phải sửa chúng. ``` $ ./configure ```, ``` ./ ``` cho phép thực thi tập lệnh trong thư mục hiện tại.
   - ``` $ make ```, bên trong nội dung gói sẽ có tệp Makefile chứa các quy tắc để xây dựng phần mềm, và khi chạy lệnh make thì nó sẽ xem tệp này để xây dựng phần mềm.
   - Lệnh để cài đặt gói, nó sẽ sao chép các tệp chính xác vào đúng vị trí trên máy tính. ``` $ sudo make install ```
   - Để gỡ cài đặt sử dụng lệnh ``` $ sudo make uninstall ```
   - Để có thể dễ dàng trong việc gỡ cài đặt và cài đặt hãy sử dụng lệnh ``` $ sudo checkinstall ```. Lệnh này sẽ thực hiện và xây dựng gói .deb và cài đặt nó để giúp dễ dàng cho việc gỡ các gói sau này.
 
## 9. Devices 
 - /dev directory
   - Khi kết nối một thiết bị với máy của mình, nó thường cần một trình điều khiển thiết bị để hoạt động bình thường. Bạn có thể tương tác với trình điều khiển thiết bị thông qua tệp thiết bị hoặc nút thiết bị, đây là những tệp đặc biệt trông giống như tệp thông thường.
   - Các tệp thiết bị này thường được lưu trữ trong thư mục /dev. Hãy tiếp tục và chọn thư mục / dev trên hệ thống, sẽ thấy một lượng lớn các tệp thiết bị có trong hệ thống. 
     ``` $ ls /dev ```
   - Khi gửi đầu ra đến /dev/null, kernel biết rằng thiết bị này lấy tất cả dữ liệu đầu vào và chỉ loại bỏ nó nên sẽ không có gì được trả lại.
 
 - device types
   - Có lệnh sau:
     ```
     $ ls -l /dev
     brw-rw----   1 root disk      8,   0 Dec 20 20:13 sda
     crw-rw-rw-   1 root root      1,   3 Dec 20 20:13 null
     srw-rw-rw-   1 root root           0 Dec 20 20:13 log
     prw-r--r--   1 root root           0 Dec 20 20:13 fdata
     ``` 
   - Từ trái sang phải tương ứng các cột như sau: quyền, người sở hữu, nhóm, số thiết bị chính, số thiết bị phụ, dấu thời gian, tên thiết bị.
   - Trong lệnh ls có thể thấy loại tệp với bit đầu tiên trên mỗi dòng, các tệp thiết bị được biễn thị:
     - c: ký tự
     - b: khối
     - p: pipe
     - s: socket 
   - Thiết bị ký tự
     - Các thiết bị này truyền dữ liệu và mỗi lần một ký tự, sẽ thấy rất nhiều thiết bị giả dưới dạng thiết bị ký tự, những thiết bị này không thực sự được kết nối vật lý với máy, nhưng chúng cho phép hệ điều hành có nhiều chức năng hơn.
   - Chặn thiết bị
     - Các thiết bị này truyền dữ liệu, nhưng trong các khối có kích thước cố định lớn. Sẽ thường thấy các thiết bị sử dụng khối dữ liệu làm thiết bị khối, chẳng hạn như ổ cứng, hệ thống tệp, v.v.
   - Thiết bị đường ống (pipe)
     - Các đường ống được đặt tên cho phép hai hoặc nhiều quy trình giao tiếp với nhau, chúng tương tự như các thiết bị ký tự, nhưng thay vì có đầu ra được gửi đến một thiết bị, nó được gửi đến một quy trình khác.
   - Thiết bị ổ cắm (socket)
     - Thiết bị ổ cắm tạo điều kiện giao tiếp giữa các quy trình, tương tự như thiết bị đường ống nhưng chúng có thể giao tiếp với nhiều quy trình cùng một lúc.
   - Đặc tính thiết bị
     - Các thiết bị được đặc trưng bằng cách sử dụng hai số, số thiết bị chính và số thiết bị phụ.
     - Trong ví dụ ls ở trên, chúng được phân tách bằng dấu phẩy. Ví dụ: giả sử một thiết bị có số thiết bị: 8, 0.
 
 - Device Names 

           


 






    
   
  


     



                 
 

  



  

   
     

 

        
 
 
